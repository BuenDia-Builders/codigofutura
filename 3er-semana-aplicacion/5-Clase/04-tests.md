# üß™ Tests Unitarios Completos - Token BDB

## Introducci√≥n

Este documento contiene los **tests esenciales** para el Token BDB. La suite completa incluye 33+ tests, pero en este documento mostramos los m√°s importantes con explicaciones detalladas.

Adem√°s de los tests mostrados se puede investigar:

- **Tests de eventos** para cada operaci√≥n (initialize, mint, burn, transfer, approve, transfer_from)
- **Tests de overflow** para detectar desbordamientos aritm√©ticos
- **Tests de cantidad negativa** en mint, transfer, y burn
- **Tests de metadata** antes y despu√©s de inicializar
- **Tests de revocaci√≥n** de allowances (approve con amount = 0)
- **Tests de atomicidad** en transfer_from (verificar que balance, allowance se actualizan juntos)
- **Tests de m√∫ltiples usuarios** con secuencias complejas de transferencias
- **Tests de consistencia** entre suma de balances y total_supply

---

## Tests Esenciales

### Imports y Setup

```rust
// src/test.rs
#![cfg(test)]

use super::*;
use soroban_sdk::{
    testutils::{Address as _, Events},
    Address, Env, String, symbol_short,
};
```

---

## 1Ô∏è‚É£ Tests de Inicializaci√≥n

### Test B√°sico de Initialize

```rust
/// Test b√°sico de inicializaci√≥n del token
/// 
/// Verifica que:
/// - El contrato se inicializa correctamente con metadatos v√°lidos
/// - Los metadatos se pueden leer despu√©s de la inicializaci√≥n
/// - El supply inicial es 0
#[test]
fn test_initialize() {
    // Arrange: Setup del entorno de testing
    let env = Env::default();
    let contract_id = env.register_contract(None, TokenBDB);
    let client = TokenBDBClient::new(&env, &contract_id);
    
    let admin = Address::generate(&env);
    let name = String::from_str(&env, "Builder Token");
    let symbol = String::from_str(&env, "BDB");
    
    // Act: Inicializar el token
    let result = client.initialize(&admin, &name, &symbol, &7);
    assert!(result.is_ok());
    
    // Assert: Verificar que los metadatos se guardaron correctamente
    assert_eq!(client.name(), name);
    assert_eq!(client.symbol(), symbol);
    assert_eq!(client.decimals(), 7);
    assert_eq!(client.total_supply(), 0);
}
```

**üí° Explicaci√≥n:**
- Usamos el patr√≥n **Arrange-Act-Assert** (AAA) para estructura clara
- `env.register_contract(None, TokenBDB)` registra el contrato para testing
- `Address::generate(&env)` crea addresses aleatorias para tests
- Verificamos que cada metadato se guard√≥ correctamente

---

### Test de Protecci√≥n contra Doble Inicializaci√≥n

```rust
/// Test de protecci√≥n contra doble inicializaci√≥n
/// 
/// Verifica que el contrato no puede ser inicializado dos veces,
/// lo cual es cr√≠tico para la seguridad del token.
#[test]
fn test_initialize_twice_fails() {
    let env = Env::default();
    let contract_id = env.register_contract(None, TokenBDB);
    let client = TokenBDBClient::new(&env, &contract_id);
    
    let admin = Address::generate(&env);
    let name = String::from_str(&env, "Token");
    let symbol = String::from_str(&env, "TOK");
    
    // Primera inicializaci√≥n debe funcionar
    assert!(client.initialize(&admin, &name, &symbol, &7).is_ok());
    
    // Segunda debe fallar con AlreadyInitialized
    let result = client.try_initialize(&admin, &name, &symbol, &7);
    assert_eq!(result, Err(Ok(TokenError::AlreadyInitialized)));
}
```

**üí° Explicaci√≥n:**
- `try_initialize` captura el error sin hacer panic
- Verificamos que el error es exactamente `AlreadyInitialized`
- Este test previene vulnerabilidades de re-inicializaci√≥n

---

### Test de Validaci√≥n de Decimales

```rust
/// Test de validaci√≥n de decimales
/// 
/// Los decimales deben estar en el rango 0-18.
/// 18 es el m√°ximo para compatibilidad con Ethereum,
/// 7 es el est√°ndar en Stellar (alineado con XLM).
#[test]
fn test_invalid_decimals() {
    let env = Env::default();
    let contract_id = env.register_contract(None, TokenBDB);
    let client = TokenBDBClient::new(&env, &contract_id);
    
    let admin = Address::generate(&env);
    
    // Decimales > 18 debe fallar
    let result = client.try_initialize(
        &admin,
        &String::from_str(&env, "Token"),
        &String::from_str(&env, "TOK"),
        &19  // ‚ùå Inv√°lido: excede MAX_DECIMALS (18)
    );
    assert_eq!(result, Err(Ok(TokenError::InvalidDecimals)));
}
```

**üí° Explicaci√≥n:**
- MAX_DECIMALS = 18 (compatibilidad Ethereum)
- Stellar usa t√≠picamente 7 decimales
- Este test valida que rechazamos valores fuera de rango

---

## 2Ô∏è‚É£ Tests de Mint

### Test B√°sico de Mint y Balance

```rust
/// Test b√°sico de mint y consulta de balance
/// 
/// Verifica el flujo completo:
/// 1. Initialize del token
/// 2. Mint de tokens a un usuario
/// 3. Consulta de balance
/// 4. Verificaci√≥n de total supply
#[test]
fn test_mint_and_balance() {
    let env = Env::default();
    let contract_id = env.register_contract(None, TokenBDB);
    let client = TokenBDBClient::new(&env, &contract_id);
    
    let admin = Address::generate(&env);
    let user = Address::generate(&env);
    
    // Initialize el token
    client.initialize(
        &admin, 
        &String::from_str(&env, "Builder Token"),
        &String::from_str(&env, "BDB"),
        &7
    ).unwrap();
    
    // Mock auth: En tests, simulamos autorizaciones sin firmas reales
    env.mock_all_auths();
    
    // Mintear 1000 tokens
    client.mint(&user, &1000).unwrap();
    
    // Verificar estado actualizado
    assert_eq!(client.balance(&user), 1000);
    assert_eq!(client.total_supply(), 1000);
}
```

**üí° Explicaci√≥n:**
- `env.mock_all_auths()` simula autorizaciones para simplificar tests
- En producci√≥n, se requiere firma real del admin
- Verificamos tanto balance individual como supply total

---

### Test de Mint con Amount = 0

```rust
/// Test: mint con amount = 0 debe fallar
/// 
/// Mintear 0 tokens no tiene sentido y podr√≠a
/// causar eventos innecesarios o confusi√≥n.
#[test]
fn test_mint_zero_fails() {
    let env = Env::default();
    let contract_id = env.register_contract(None, TokenBDB);
    let client = TokenBDBClient::new(&env, &contract_id);
    
    let admin = Address::generate(&env);
    let user = Address::generate(&env);
    
    client.initialize(
        &admin,
        &String::from_str(&env, "Token"),
        &String::from_str(&env, "TOK"),
        &7
    ).unwrap();
    
    env.mock_all_auths();
    
    // Mintear 0 debe fallar con InvalidAmount
    let result = client.try_mint(&user, &0);
    assert_eq!(result, Err(Ok(TokenError::InvalidAmount)));
}
```

**üí° Explicaci√≥n:**
- Este es un "edge case" importante
- Previene operaciones sin sentido
- El contrato debe validar amount > 0

---

## 3Ô∏è‚É£ Tests de Transfer

### Test B√°sico de Transfer

```rust
/// Test b√°sico de transferencia entre dos usuarios
/// 
/// Verifica el flujo completo de transfer:
/// 1. Alice tiene 1000 tokens
/// 2. Alice transfiere 250 tokens a Bob
/// 3. Ambos balances se actualizan correctamente
#[test]
fn test_transfer() {
    let env = Env::default();
    let contract_id = env.register_contract(None, TokenBDB);
    let client = TokenBDBClient::new(&env, &contract_id);
    
    let admin = Address::generate(&env);
    let alice = Address::generate(&env);
    let bob = Address::generate(&env);
    
    // Setup: Initialize y dar tokens a Alice
    client.initialize(
        &admin,
        &String::from_str(&env, "Builder Token"),
        &String::from_str(&env, "BDB"),
        &7
    ).unwrap();
    
    env.mock_all_auths();
    client.mint(&alice, &1000).unwrap();
    
    // Act: Alice transfiere a Bob
    client.transfer(&alice, &bob, &250).unwrap();
    
    // Assert: Verificar ambos balances
    assert_eq!(client.balance(&alice), 750);  // 1000 - 250
    assert_eq!(client.balance(&bob), 250);
}
```

**üí° Explicaci√≥n:**
- Transfer actualiza dos balances simult√°neamente
- Verificamos que la suma de tokens se conserva
- Este es el test m√°s importante del token

---

### Test de Balance Insuficiente

```rust
/// Test: transfer con balance insuficiente debe fallar
/// 
/// No puedes transferir m√°s tokens de los que tienes.
/// Este es uno de los errores m√°s comunes en tokens.
#[test]
fn test_transfer_insufficient_balance() {
    let env = Env::default();
    let contract_id = env.register_contract(None, TokenBDB);
    let client = TokenBDBClient::new(&env, &contract_id);
    
    let admin = Address::generate(&env);
    let alice = Address::generate(&env);
    let bob = Address::generate(&env);
    
    client.initialize(
        &admin,
        &String::from_str(&env, "Token"),
        &String::from_str(&env, "TOK"),
        &7
    ).unwrap();
    
    env.mock_all_auths();
    client.mint(&alice, &100).unwrap();
    
    // Intentar transferir m√°s de lo que tiene debe fallar
    let result = client.try_transfer(&alice, &bob, &200);
    assert_eq!(result, Err(Ok(TokenError::InsufficientBalance)));
}
```

**üí° Explicaci√≥n:**
- Este test previene uno de los bugs m√°s comunes
- El contrato debe validar `balance >= amount` antes de transferir
- El error debe ser espec√≠fico: `InsufficientBalance`

---

### Test de Transfer a S√≠ Mismo

```rust
/// Test: transfer a s√≠ mismo debe fallar
/// 
/// Decisi√≥n de dise√±o: prohibimos transferencias a s√≠ mismo por:
/// - Ahorro de gas (operaci√≥n in√∫til)
/// - Evitar eventos confusos
/// - Prevenir errores del usuario
#[test]
fn test_transfer_to_self() {
    let env = Env::default();
    let contract_id = env.register_contract(None, TokenBDB);
    let client = TokenBDBClient::new(&env, &contract_id);
    
    let admin = Address::generate(&env);
    let alice = Address::generate(&env);
    
    client.initialize(
        &admin,
        &String::from_str(&env, "Token"),
        &String::from_str(&env, "TOK"),
        &7
    ).unwrap();
    
    env.mock_all_auths();
    client.mint(&alice, &1000).unwrap();
    
    // Transfer a s√≠ mismo debe fallar con InvalidRecipient
    let result = client.try_transfer(&alice, &alice, &100);
    assert_eq!(result, Err(Ok(TokenError::InvalidRecipient)));
    assert_eq!(client.balance(&alice), 1000); // Balance no debe cambiar
}
```

**üí° Explicaci√≥n:**
- Esta es una **decisi√≥n de dise√±o** (no todos los tokens la implementan)
- Razones: ahorro de gas, evitar confusi√≥n, prevenir errores
- Alternativa v√°lida: permitirlo como no-op (return Ok sin hacer nada)

---

## 4Ô∏è‚É£ Tests de Approve y Transfer From

### Test del Flujo Completo Approve + Transfer From

```rust
/// Test del flujo completo de approve + transfer_from
/// 
/// Este es el patr√≥n "allowance" usado en DeFi:
/// 1. Alice aprueba a Bob para gastar hasta 300 tokens
/// 2. Bob usa transfer_from para mover 200 tokens de Alice a Charlie
/// 3. El allowance se reduce autom√°ticamente a 100
#[test]
fn test_approve_and_transfer_from() {
    let env = Env::default();
    let contract_id = env.register_contract(None, TokenBDB);
    let client = TokenBDBClient::new(&env, &contract_id);
    
    let admin = Address::generate(&env);
    let alice = Address::generate(&env);
    let bob = Address::generate(&env);
    let charlie = Address::generate(&env);
    
    // Setup
    client.initialize(
        &admin,
        &String::from_str(&env, "Token"),
        &String::from_str(&env, "TOK"),
        &7
    ).unwrap();
    
    env.mock_all_auths();
    client.mint(&alice, &1000).unwrap();
    
    // Alice aprueba a Bob para gastar hasta 300 tokens
    client.approve(&alice, &bob, &300).unwrap();
    assert_eq!(client.allowance(&alice, &bob), 300);
    
    // Bob transfiere 200 tokens de Alice a Charlie
    client.transfer_from(&bob, &alice, &charlie, &200).unwrap();
    
    // Verificar estado final
    assert_eq!(client.balance(&alice), 800);          // 1000 - 200
    assert_eq!(client.balance(&charlie), 200);        // 0 + 200
    assert_eq!(client.allowance(&alice, &bob), 100);  // 300 - 200
}
```

**üí° Explicaci√≥n:**
- Este es el patr√≥n usado por DEXs y protocolos DeFi
- **Approve** da permiso, **transfer_from** lo ejecuta
- El allowance se reduce autom√°ticamente
- Bob necesita autorizaci√≥n, Alice no (ya dio approve)

---

### Test de Allowance Insuficiente

```rust
/// Test: transfer_from con allowance insuficiente debe fallar
/// 
/// Bob solo puede gastar hasta el l√≠mite aprobado por Alice.
#[test]
fn test_transfer_from_insufficient_allowance() {
    let env = Env::default();
    let contract_id = env.register_contract(None, TokenBDB);
    let client = TokenBDBClient::new(&env, &contract_id);
    
    let admin = Address::generate(&env);
    let alice = Address::generate(&env);
    let bob = Address::generate(&env);
    let charlie = Address::generate(&env);
    
    client.initialize(
        &admin,
        &String::from_str(&env, "Token"),
        &String::from_str(&env, "TOK"),
        &7
    ).unwrap();
    
    env.mock_all_auths();
    client.mint(&alice, &1000).unwrap();
    client.approve(&alice, &bob, &100).unwrap();  // Solo 100 aprobados
    
    // Bob intenta transferir m√°s de lo aprobado
    let result = client.try_transfer_from(&bob, &alice, &charlie, &200);
    assert_eq!(result, Err(Ok(TokenError::InsufficientAllowance)));
}
```

**üí° Explicaci√≥n:**
- Este test verifica que el sistema de allowances funciona
- Bob no puede exceder el l√≠mite aprobado por Alice
- Error espec√≠fico: `InsufficientAllowance` (no `InsufficientBalance`)

---

## 5Ô∏è‚É£ Tests de Burn

### Test B√°sico de Burn

```rust
/// Test b√°sico de burn (quemar tokens)
/// 
/// Burn reduce tanto el balance del usuario como el supply total.
/// Es usado para reducir supply (deflaci√≥n), fees, etc.
#[test]
fn test_burn() {
    let env = Env::default();
    let contract_id = env.register_contract(None, TokenBDB);
    let client = TokenBDBClient::new(&env, &contract_id);
    
    let admin = Address::generate(&env);
    let alice = Address::generate(&env);
    
    client.initialize(
        &admin,
        &String::from_str(&env, "Token"),
        &String::from_str(&env, "TOK"),
        &7
    ).unwrap();
    
    env.mock_all_auths();
    client.mint(&alice, &1000).unwrap();
    
    // Alice quema 300 de sus tokens
    client.burn(&alice, &300).unwrap();
    
    // Verificar que tanto balance como supply se redujeron
    assert_eq!(client.balance(&alice), 700);    // 1000 - 300
    assert_eq!(client.total_supply(), 700);     // 1000 - 300
}
```

**üí° Explicaci√≥n:**
- Burn es el proceso inverso a mint
- Reduce **tanto balance como supply total**
- Usado para: deflaci√≥n, quemar fees, eliminar tokens

---

## 6Ô∏è‚É£ Test de Operaciones sin Inicializar

```rust
/// Test: todas las operaciones deben fallar si no se inicializ√≥
/// 
/// Verifica que el flag de inicializaci√≥n se verifica en
/// TODAS las funciones que modifican estado.
#[test]
fn test_operations_without_init() {
    let env = Env::default();
    let contract_id = env.register_contract(None, TokenBDB);
    let client = TokenBDBClient::new(&env, &contract_id);
    
    let alice = Address::generate(&env);
    let bob = Address::generate(&env);
    
    env.mock_all_auths();
    
    // Todas las operaciones deben fallar con NotInitialized
    assert_eq!(
        client.try_mint(&alice, &100),
        Err(Ok(TokenError::NotInitialized))
    );
    
    assert_eq!(
        client.try_transfer(&alice, &bob, &50),
        Err(Ok(TokenError::NotInitialized))
    );
    
    assert_eq!(
        client.try_burn(&alice, &10),
        Err(Ok(TokenError::NotInitialized))
    );
}
```

**üí° Explicaci√≥n:**
- Este test verifica que **todas** las funciones verifican inicializaci√≥n
- Previene uso del contrato antes de setup completo
- Cada funci√≥n debe fallar con el mismo error: `NotInitialized`

---

## Ejecutar los Tests

### Comandos B√°sicos

```powershell
# Ejecutar todos los tests
cargo test

# Ver output detallado
cargo test -- --nocapture

# Test espec√≠fico
cargo test test_transfer

# Tests en modo release (m√°s r√°pido)
cargo test --release
```

### Cobertura de Tests

```powershell
# Instalar cargo-tarpaulin (una sola vez)
cargo install cargo-tarpaulin

# Generar reporte de cobertura
cargo tarpaulin --out Html

# Abrir reporte en Windows
start tarpaulin-report.html
```

---

## üìä Resumen de Tests

### Tests Mostrados en este Documento (Esenciales)

| Categor√≠a | Tests | Descripci√≥n |
|-----------|-------|-------------|
| **Inicializaci√≥n** | 3 | Setup, doble init, decimales inv√°lidos |
| **Mint** | 2 | Mint b√°sico, amount = 0 |
| **Transfer** | 3 | Transfer b√°sico, balance insuficiente, a s√≠ mismo |
| **Approve/TransferFrom** | 2 | Flujo completo, allowance insuficiente |
| **Burn** | 1 | Burn b√°sico |
| **Sin Inicializar** | 1 | Operaciones antes de init |

**Total Mostrados: 12 tests esenciales**

### Tests Adicionales Recomendados (No Mostrados)

- ‚úÖ 6 tests de eventos (uno por cada operaci√≥n)
- ‚úÖ 3 tests de overflow/underflow
- ‚úÖ 2 tests de cantidades negativas
- ‚úÖ 3 tests de validaci√≥n de metadata
- ‚úÖ 2 tests de atomicidad
- ‚úÖ 5 tests avanzados de m√∫ltiples usuarios

**Total Recomendado: 33+ tests para cobertura completa**

---

## üéØ Patrones de Testing Usados

### 1. Arrange-Act-Assert (AAA)
```
Arrange: Setup del entorno y datos
Act: Ejecutar la operaci√≥n a testear
Assert: Verificar el resultado esperado
```

### 2. Test de Errores con try_*
```rust
let result = client.try_mint(&user, &0);
assert_eq!(result, Err(Ok(TokenError::InvalidAmount)));
```

### 3. Mock de Autenticaci√≥n
```rust
env.mock_all_auths();  // Simula firmas sin cryptograf√≠a
```

---

## ‚úÖ Checklist de Testing

Antes de considerar los tests completos:

- [ ] ‚úÖ Tests de happy path (flujos normales)
- [ ] ‚úÖ Tests de edge cases (0, negativos, m√°ximos)
- [ ] ‚úÖ Tests de errores esperados
- [ ] ‚úÖ Tests de eventos (CAP-46 obligatorio)
- [ ] ‚úÖ Tests sin inicializar
- [ ] ‚úÖ Todos los tests pasan: `cargo test`
- [ ] ‚úÖ Cobertura > 90%: `cargo tarpaulin`

---

## üìö Referencias

- [Soroban Testing Guide](https://developers.stellar.org/docs/build/guides/testing)
- [CAP-46 Token Standard](https://stellar.org/protocol/cap-46)
- [Soroban SDK testutils](https://docs.rs/soroban-sdk/latest/soroban_sdk/testutils/)

---

*Suite de tests esenciales para garantizar un token robusto y seguro ü¶à*