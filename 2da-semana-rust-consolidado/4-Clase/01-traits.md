# ü¶à Parte 1: Traits e Implementaciones
## El lenguaje com√∫n de los contratos inteligentes

**Tiempo estimado:** 25-30 minutos (22 min lectura + 5-8 min reflexi√≥n/pr√°ctica)

---

## üìñ Mini-glosario (referencia r√°pida)

T√©rminos que ver√°s en esta secci√≥n:

**Trait:** "Contrato de comportamiento" - define funciones que un tipo debe tener  
**Address:** Direcci√≥n en blockchain (como una billetera o contrato)  
**Symbol:** Texto corto en Soroban (m√°x 32 caracteres), usado para nombres  
**Storage:** "Base de datos" persistente en blockchain donde guardas datos  
**Ownable:** Patr√≥n est√°ndar para control de acceso (qui√©n es due√±o del contrato)

---

## üéØ ¬øQu√© vas a entender en esta secci√≥n?

Al final de estos 25-30 minutos, vas a poder:

- [ ] Explicar qu√© es un trait y por qu√© existe
- [ ] Entender por qu√© los traits son cr√≠ticos en blockchain
- [ ] Identificar cu√°ndo usar traits en tus propios contratos
- [ ] Reconocer el patr√≥n Ownable (control de acceso)
- [ ] Diferenciar entre c√≥digo con y sin traits

---

## üí° El problema que resuelven los traits

### Imagina esta situaci√≥n:

Tu amiga Mar√≠a est√° construyendo una plataforma de donaciones. Quiere que diferentes ONGs puedan recibir fondos, pero cada ONG tiene su propia forma de hacer las cosas:

**ONG de Educaci√≥n:**
```rust
struct DonacionEducacion {
    beneficiaria: Address,  // üìç Address = direcci√≥n en blockchain
    monto: i128,
}

// Sus funciones
fn obtener_beneficiaria() { ... }
fn obtener_monto() { ... }
```

**ONG de Salud:**
```rust
struct DonacionSalud {
    receptora: Address,  // ü§î Nota: nombre diferente (Address es lo mismo)
    cantidad: i128,      // ü§î Nota: "cantidad" vs "monto"
}

// Sus funciones
fn get_receptora() { ... }  // ü§î Nota: "get_receptora" vs "obtener_beneficiaria"
fn get_cantidad() { ... }   // ü§î Nota: nombres completamente diferentes
}
```

> **üí° ¬øQu√© es Address?**  
> `Address` es un tipo de dato en Soroban que representa una direcci√≥n en la blockchain. Piensa en ella como la "direcci√≥n de email" de una billetera o contrato - √∫nica e inmutable.

### El problema real:

Mar√≠a quiere crear una funci√≥n que procese CUALQUIER tipo de donaci√≥n:

```rust
fn procesar_donaciones(donaciones: Vec<???>) {
    for donacion in donaciones {
        // ‚ùå ¬øC√≥mo obtengo la beneficiaria?
        // ¬øEs "beneficiaria", "receptora", o "destinataria"?
        
        // ‚ùå ¬øC√≥mo obtengo el monto?
        // ¬øEs "monto", "cantidad", o "valor"?
    }
}
```

**Sin traits, Mar√≠a necesitar√≠a c√≥digo diferente para cada ONG:**

```rust
// ‚ùå C√≥digo sin traits - repetitivo y fr√°gil
fn procesar_donaciones(donaciones: Vec<Donacion>) {
    for donacion in donaciones {
        if donacion.tipo == "educacion" {
            let benef = donacion.obtener_beneficiaria();
            let monto = donacion.obtener_monto();
        } else if donacion.tipo == "salud" {
            let benef = donacion.get_receptora();  // Nombre diferente ‚ùå
            let monto = donacion.get_cantidad();   // Nombre diferente ‚ùå
        } else if donacion.tipo == "ambiente" {
            // Otro c√≥digo diferente...
        }
        // ... 10 ONGs m√°s = 10 bloques de c√≥digo diferentes
    }
}
```

**Resultado:** Mar√≠a tiene que reescribir TODO cada vez que llega una ONG nueva. Si llegan 10 ONGs, tiene 10 versiones del mismo c√≥digo.

---

## ‚úÖ La soluci√≥n: Traits (Contratos de comportamiento)

Un **trait** es como un acuerdo o contrato:

> "Si quieres participar en mi plataforma, DEBES tener estas funciones con estos nombres exactos."

**Analog√≠a del mundo real:**

Imagina que est√°s organizando un evento de emprendedoras. Para participar, TODAS deben cumplir:
- Tener un n√∫mero de identificaci√≥n
- Poder mostrar sus productos
- Aceptar pagos digitales

No importa si eres artesana, cocinera, o dise√±adora - si cumples esos 3 requisitos, puedes participar.

**Los traits funcionan igual:** Definen requisitos que todos deben cumplir.

### Veamos el c√≥digo:

```rust
// DEFINICI√ìN DEL TRAIT
// Esto es el "contrato" que todos deben cumplir
trait Donacion {
    fn beneficiaria(&self) -> Address;
    fn monto(&self) -> i128;
    fn procesar(&mut self, donante: Address) -> Result<(), Error>;
}
```

**An√°lisis l√≠nea por l√≠nea:**

1. **`trait Donacion`** 
   - Estamos creando un "contrato de comportamiento"
   - Cualquier struct que quiera ser "Donacion" debe implementarlo

2. **`fn beneficiaria(&self) -> Address`** 
   - Toda donaci√≥n DEBE poder decir qui√©n es la beneficiaria
   - Retorna `Address` (la direcci√≥n de la beneficiaria)
   - `&self` significa "esta funci√≥n puede leer los datos de la struct"

3. **`fn monto(&self) -> i128`** 
   - Toda donaci√≥n DEBE poder decir cu√°l es el monto
   - Retorna `i128` (n√∫mero entero grande para evitar problemas de redondeo)

4. **`fn procesar(...)`** 
   - Toda donaci√≥n DEBE tener una forma de procesarse
   - `&mut self` significa "puede modificar los datos de la struct"
   - Retorna `Result` porque puede fallar

---

### Ahora cada ONG implementa el trait:

```rust
// ONG de Educaci√≥n IMPLEMENTA el trait
struct DonacionEducacion {
    beneficiaria: Address,
    monto: i128,
    escuela: Symbol,  // üìç Symbol = texto corto en Soroban (m√°x 32 chars)
}

impl Donacion for DonacionEducacion {
    fn beneficiaria(&self) -> Address {
        self.beneficiaria.clone()
    }
    
    fn monto(&self) -> i128 {
        self.monto
    }
    
    fn procesar(&mut self, donante: Address) -> Result<(), Error> {
        // L√≥gica espec√≠fica para donaciones educativas
        // Por ejemplo: verificar que la escuela est√© registrada
        Ok(())
    }
}
```

```rust
// ONG de Salud IMPLEMENTA el trait
struct DonacionSalud {
    beneficiaria: Address,  // ‚úÖ Ahora usa el mismo nombre internamente
    monto: i128,
    hospital: Symbol,  // Dato espec√≠fico de salud
}

impl Donacion for DonacionSalud {
    fn beneficiaria(&self) -> Address {
        self.beneficiaria.clone()
    }
    
    fn monto(&self) -> i128 {
        self.monto
    }
    
    fn procesar(&mut self, donante: Address) -> Result<(), Error> {
        // L√≥gica espec√≠fica para donaciones de salud
        // Por ejemplo: verificar que el hospital tenga licencia
        Ok(())
    }
}
```

---

### El poder de los traits:

Ahora Mar√≠a puede escribir UNA funci√≥n que trabaje con TODAS las donaciones:

```rust
// ‚úÖ C√≥digo con traits - funciona con CUALQUIER donaci√≥n
// Esta funci√≥n trabaja con CUALQUIER tipo que implemente Donacion
fn registrar_donacion<T: Donacion>(donacion: &T, registro: &mut Vec<Address>) {
    // ‚úÖ Sabemos que TIENE que tener beneficiaria()
    registro.push(donacion.beneficiaria());
    
    // ‚úÖ Sabemos que TIENE que tener monto()
    let total = donacion.monto();
    
    // No importa si es DonacionEducacion o DonacionSalud
    // ¬°Funciona con ambas!
}
```

**Decisi√≥n de dise√±o clave:**
- `<T: Donacion>` significa "T puede ser cualquier tipo, PERO debe implementar Donacion"
- El compilador GARANTIZA que T tiene las funciones `beneficiaria()` y `monto()`
- No hay posibilidad de error en runtime - todo se verifica en compilaci√≥n

**Ventajas del enfoque con traits:**
- **Estandarizaci√≥n:** Todas las donaciones tienen la misma interfaz
- **Interoperabilidad:** Un contrato puede trabajar con cualquier tipo de donaci√≥n
- **Extensibilidad:** Agregar nuevos tipos de donaci√≥n no requiere cambiar c√≥digo existente
- **Type safety:** El compilador verifica que implementemos todos los m√©todos requeridos

---

## üåü ¬øPor qu√© son especialmente cr√≠ticos en blockchain?

En blockchain, los traits son a√∫n m√°s importantes que en programaci√≥n tradicional:

**1. Interoperabilidad entre contratos desconocidos**
- En una blockchain p√∫blica, miles de contratos de diferentes desarrolladores deben interactuar
- Los traits aseguran que todos "hablan el mismo idioma"
- Un DEX puede interactuar con CUALQUIER token que implemente el trait Token est√°ndar

**2. Auditor√≠as de seguridad**
- Si tu contrato sigue un trait est√°ndar (como Token), los auditores ya saben qu√© esperar
- M√°s f√°cil encontrar vulnerabilidades
- Menos sorpresas = m√°s seguro

**3. Composabilidad**
- Los contratos pueden construirse unos sobre otros
- Tu token puede funcionar en CUALQUIER exchange que espere el trait Token
- "Lego blocks" de finanzas descentralizadas

**Ejemplo real:**  
Cuando Stellar lanz√≥ Soroban, defini√≥ el trait est√°ndar para tokens. Ahora CUALQUIER DEX, wallet, o aplicaci√≥n puede interactuar con CUALQUIER token que implemente ese trait - sin conocer los detalles internos.

---

## ü™ô Ejemplo adicional: Trait Token (est√°ndar blockchain)

Veamos otro caso com√∫n - un trait para tokens (como ERC-20 en Ethereum):

```rust
// Trait est√°ndar para tokens en blockchain
trait Token {
    fn balance_of(&self, env: &Env, owner: Address) -> i128;
    fn transfer(&self, env: &Env, from: Address, to: Address, amount: i128) -> Result<(), Error>;
    fn total_supply(&self, env: &Env) -> i128;
}
```

**¬øPor qu√© este trait es poderoso?**

Imagina que construyes un exchange (DEX). Con este trait, tu exchange puede listar CUALQUIER token que lo implemente:

```rust
// Tu DEX puede trabajar con cualquier token
fn swap<T: Token>(token_a: &T, token_b: &T, amount: i128) {
    // Sab√©s que ambos tokens tienen balance_of y transfer
    let balance = token_a.balance_of(&env, usuario);
    token_a.transfer(&env, usuario, exchange, amount)?;
    // ... l√≥gica de swap
}
```

**Sin traits, necesitar√≠as:**
- C√≥digo espec√≠fico para cada token
- Verificar manualmente qu√© funciones tiene cada uno
- Actualizar tu exchange cada vez que sale un token nuevo

**Con traits:**
- Un solo c√≥digo funciona con TODOS los tokens
- Los nuevos tokens funcionan autom√°ticamente
- Zero code changes necesarios

---

## üîí Patr√≥n Ownable: Control de acceso en contratos

Uno de los traits M√ÅS IMPORTANTES en contratos inteligentes es **Ownable**.

### ¬øPor qu√© existe?

En blockchain, muchos contratos necesitan funciones administrativas que SOLO una persona puede ejecutar:

- Cambiar tasas de inter√©s
- Pausar el contrato en emergencia
- Agregar nuevos administradores
- Actualizar configuraciones

**Pregunta cr√≠tica:** ¬øC√≥mo evitamos que CUALQUIERA ejecute estas funciones?

**Respuesta:** El patr√≥n Ownable.

---

### Implementaci√≥n del trait Ownable:

**Primero, definimos qu√© funciones DEBE tener un contrato "Ownable":**

```rust
use soroban_sdk::{contracttype, Env, Address};

// El trait Ownable define el "contrato" de control de acceso
// Es como un acuerdo: "Si tu contrato es Ownable, DEBE tener estas 3 funciones"
trait Ownable {
    // Funci√≥n 1: Consultar qui√©n es el due√±o
    fn get_owner(&self, env: &Env) -> Address;
    
    // Funci√≥n 2: Transferir el ownership a otra persona
    fn transfer_ownership(&self, env: &Env, new_owner: Address) -> Result<(), Error>;
    
    // Funci√≥n 3: Verificar que quien llama es el due√±o (guardi√°n)
    fn require_owner(&self, env: &Env, caller: Address) -> Result<(), Error>;
}
```

**¬øQu√© hace cada funci√≥n?**

| Funci√≥n | Prop√≥sito | Ejemplo de uso |
|---------|-----------|----------------|
| `get_owner()` | Consultar qui√©n es el due√±o actual | "¬øQui√©n controla este contrato?" |
| `transfer_ownership()` | Cambiar el due√±o (solo el owner actual puede) | "Vendo mi negocio, el nuevo due√±o es Ana" |
| `require_owner()` | Verificar que el caller es el owner | "Antes de cambiar la tasa, verifico que seas el due√±o" |

**Analog√≠a:** Es como tener las llaves de un negocio:
- `get_owner()` ‚Üí Ver en el registro qui√©n tiene las llaves
- `transfer_ownership()` ‚Üí Entregar las llaves a otra persona
- `require_owner()` ‚Üí Verificar que quien intenta abrir la caja fuerte tiene las llaves

---

### ¬øD√≥nde guardamos el owner?

Necesitamos definir las "keys" para el storage:

```rust
#[contracttype]
#[derive(Clone)]
pub enum DataKey {
    Owner,  // Aqu√≠ se guarda la direcci√≥n del owner
}
```

> **üí° ¬øQu√© es storage?**  
> El storage en Soroban es como una base de datos persistente en la blockchain donde guardamos datos clave. Cada dato necesita una "key" para identificarlo - como un diccionario donde cada entrada tiene una clave √∫nica.

**Decisi√≥n de dise√±o:**
- Usamos un `enum` para organizar las keys del storage (mejor que strings)
- `Owner` es una key de "instance storage" (configuraci√≥n del contrato)
- Lo veremos en detalle en la Parte 3

---

### Implementaci√≥n completa con comentarios detallados:

```rust
#[contract]
pub struct MiContrato;

#[contractimpl]
impl Ownable for MiContrato {
    
    // FUNCI√ìN 1: Obtener el owner actual
    fn get_owner(&self, env: &Env) -> Address {
        env.storage()                    // 1Ô∏è‚É£ Acceder al almacenamiento del contrato
            .instance()                  // 2Ô∏è‚É£ Usar el storage de "configuraci√≥n global"
            .get(&DataKey::Owner)        // 3Ô∏è‚É£ Buscar el valor guardado en la key "Owner"
            .expect("Owner no inicializado")  // 4Ô∏è‚É£ Si no existe ‚Üí ERROR fatal
        
        // ‚ö†Ô∏è ¬øPor qu√© expect() y no unwrap_or()?
        // Porque si no hay owner, el contrato est√° MAL configurado
        // Mejor fallar expl√≠citamente que asumir un valor por defecto
    }
    
    // FUNCI√ìN 2: Transferir ownership a otra persona
    fn transfer_ownership(&self, env: &Env, new_owner: Address) -> Result<(), Error> {
        // PASO 1: Obtener quien est√° llamando esta funci√≥n
        let caller = env.current_contract_address(); // Simplificado para el ejemplo
        
        // PASO 2: VALIDAR PRIMERO - Verificar que el caller ES el owner actual
        self.require_owner(env, caller)?;
        // ‚òùÔ∏è El "?" significa: si require_owner retorna error, salir inmediatamente
        
        // PASO 3: Si llegamos aqu√≠, el caller es el owner
        // AHORA S√ç es seguro cambiar el owner en storage
        env.storage()
            .instance()                      // Acceder al storage de configuraci√≥n
            .set(&DataKey::Owner, &new_owner); // Guardar el nuevo owner
        
        Ok(())  // ‚úÖ √âxito - ownership transferido
    }
    
    // FUNCI√ìN 3: El "guardi√°n" - Verificar que caller es owner
    fn require_owner(&self, env: &Env, caller: Address) -> Result<(), Error> {
        // PASO 1: Obtener el owner guardado en storage
        let owner = self.get_owner(env);
        
        // PASO 2: Comparar el caller con el owner guardado
        if caller != owner {
            // ‚ùå No coinciden ‚Üí retornar error
            return Err(Error::NotOwner);
        }
        
        // ‚úÖ Coinciden ‚Üí todo bien
        Ok(())
    }
}
```

**üîç An√°lisis paso a paso de cada funci√≥n:**

#### Funci√≥n 1: `get_owner()` - La consulta
```rust
env.storage().instance().get(&DataKey::Owner).expect("mensaje")
```

**Desglose:**
1. `env.storage()` ‚Üí Acceder al sistema de almacenamiento
2. `.instance()` ‚Üí Zona de "configuraci√≥n global" del contrato
3. `.get(&DataKey::Owner)` ‚Üí Buscar el valor asociado a la key "Owner"
4. `.expect("...")` ‚Üí Si no existe, detener todo con este mensaje de error

**üí° ¬øPor qu√© expect()?**  
Porque si no hay owner configurado, el contrato NO est√° listo para usarse. Es mejor fallar de forma clara que continuar en un estado inv√°lido.

#### Funci√≥n 2: `transfer_ownership()` - El cambio de manos
```rust
self.require_owner(env, caller)?;  // ‚Üê Primero valida
env.storage().instance().set(...); // ‚Üê Despu√©s modifica
```

**Orden cr√≠tico:**
1. ‚úÖ PRIMERO: Verificar permisos (require_owner)
2. ‚úÖ DESPU√âS: Modificar storage (set)

**‚ùå NUNCA al rev√©s:**
```rust
// ‚ùå MAL - No hagas esto
env.storage().instance().set(...);  // Modificar primero
self.require_owner(env, caller)?;   // Validar despu√©s ‚Üí ya es tarde!
```

**¬øPor qu√©?** Si la validaci√≥n falla DESPU√âS de modificar, ya cambiaste el owner. El da√±o est√° hecho.

#### Funci√≥n 3: `require_owner()` - El guardi√°n
```rust
if caller != owner {
    return Err(Error::NotOwner);  // Salir inmediatamente con error
}
Ok(())  // Solo si la verificaci√≥n pas√≥
```

**Patr√≥n:** Early return on error
- Si hay problema ‚Üí salir inmediatamente
- Si todo est√° bien ‚Üí continuar hasta el final

---

## üåü Caso de uso real: Contrato de Microcr√©ditos

Imagina un contrato que otorga microcr√©ditos a emprendedoras:

```rust
#[contract]
pub struct MicroCredito;

#[contractimpl]
impl MicroCredito {
    // ‚úÖ Funci√≥n p√∫blica - cualquiera puede llamarla
    pub fn solicitar_credito(env: Env, solicitante: Address, monto: i128) -> Result<(), Error> {
        // L√≥gica para solicitar cr√©dito
        Ok(())
    }
    
    // ‚ö†Ô∏è Funci√≥n administrativa - SOLO el owner
    pub fn cambiar_tasa_interes(env: Env, caller: Address, nueva_tasa: u32) -> Result<(), Error> {
        // PRIMERO: Verificar que el caller es el owner
        Self::require_owner(&env, caller)?;
        
        // SEGUNDO: Si llegamos aqu√≠, es seguro cambiar la tasa
        env.storage()
            .instance()
            .set(&DataKey::TasaInteres, &nueva_tasa);
        
        Ok(())
    }
}
```

**An√°lisis de seguridad:**

1. **`solicitar_credito()`:**
   - ‚úÖ P√∫blica
   - ‚úÖ Cualquier emprendedora puede llamarla
   - ‚úÖ No requiere permisos especiales

2. **`cambiar_tasa_interes()`:**
   - ‚ö†Ô∏è Administrativa
   - ‚ö†Ô∏è Solo el owner puede ejecutarla
   - ‚ö†Ô∏è `require_owner()` protege esta funci√≥n

**¬øQu√© pasa si alguien m√°s intenta cambiar la tasa?**

```rust
// Escenario: Una usuaria maliciosa intenta cambiar la tasa
let usuaria_maliciosa = Address::generate(&env);
let resultado = contrato.cambiar_tasa_interes(env, usuaria_maliciosa, 100);

// Resultado: Err(Error::NotOwner)
// ‚úÖ El contrato rechaza la operaci√≥n
// ‚úÖ No se cambia la tasa
// ‚úÖ No se desperdicia gas en operaciones inv√°lidas
```

---

## üîç Traits en Soroban SDK (lo que viene incorporado)

Cuando usas los macros de Soroban, autom√°ticamente se implementan traits importantes:

```rust
use soroban_sdk::{contract, contractimpl, Env, Symbol};

#[contract]  // üëà Este macro implementa traits autom√°ticamente
pub struct MiContrato;

#[contractimpl]  // üëà Este macro tambi√©n
impl MiContrato {
    pub fn saludar(env: Env, nombre: Symbol) -> Symbol {
        Symbol::new(&env, "Hola")
    }
}
```

**¬øQu√© traits se implementan autom√°ticamente?**

1. **IntoVal / TryFromVal:**
   - Conversi√≥n entre tipos Rust ‚Üí tipos Soroban
   - Ejemplo: `i128` (Rust) ‚ÜîÔ∏è `Val` (Soroban)

2. **Contract:**
   - Marca la struct como contrato invocable
   - Permite que la blockchain llame tus funciones

3. **Serializaci√≥n:**
   - Tus par√°metros se serializan/deserializan autom√°ticamente
   - No tienes que escribir c√≥digo de conversi√≥n manual

**Decisi√≥n de dise√±o de Soroban:**
- Los macros ocultan la complejidad
- T√∫ escribes Rust normal
- El SDK maneja la comunicaci√≥n con la blockchain

---

## üìä Comparaci√≥n visual: SIN traits vs CON traits

### Escenario: Procesar 3 tipos de donaciones diferentes

#### ‚ùå SIN traits - C√≥digo espec√≠fico para cada tipo

```rust
fn procesar_todas_donaciones(
    educacion: Vec<DonacionEducacion>,
    salud: Vec<DonacionSalud>,
    ambiente: Vec<DonacionAmbiente>
) {
    // Procesar educaci√≥n
    for don in educacion {
        let benef = don.obtener_beneficiaria();  // Nombre espec√≠fico
        let monto = don.obtener_monto();
        registrar(benef, monto);
    }
    
    // Procesar salud - C√ìDIGO REPETIDO
    for don in salud {
        let benef = don.get_receptora();  // Nombre diferente ‚ùå
        let cantidad = don.get_cantidad();  // Nombre diferente ‚ùå
        registrar(benef, cantidad);
    }
    
    // Procesar ambiente - M√ÅS C√ìDIGO REPETIDO
    for don in ambiente {
        let dest = don.destinataria();  // Otro nombre diferente ‚ùå
        let valor = don.valor();  // Otro nombre diferente ‚ùå
        registrar(dest, valor);
    }
}

// Problema: Si llega un 4to tipo, escribir TODO de nuevo
```

**Resultado:** 
- 3 bloques de c√≥digo casi id√©nticos
- Dif√≠cil de mantener
- Agregar un tipo nuevo = reescribir funci√≥n completa

---

#### ‚úÖ CON traits - C√≥digo unificado

```rust
fn procesar_todas_donaciones<T: Donacion>(donaciones: Vec<T>) {
    for don in donaciones {
        let benef = don.beneficiaria();  // ‚úÖ Mismo nombre siempre
        let monto = don.monto();  // ‚úÖ Mismo nombre siempre
        registrar(benef, monto);
    }
}

// Funciona con CUALQUIER tipo que implemente Donacion:
procesar_todas_donaciones(educacion_vec);
procesar_todas_donaciones(salud_vec);
procesar_todas_donaciones(ambiente_vec);
// Agregar un 4to tipo: CERO cambios en esta funci√≥n
```

**Resultado:**
- UN solo bloque de c√≥digo
- F√°cil de mantener
- Agregar tipo nuevo = CERO cambios (solo implementar el trait)

---

### Diagrama conceptual:

```
SIN TRAITS:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Contrato Token  ‚îÇ     ‚îÇ Contrato NFT    ‚îÇ     ‚îÇ Contrato DAO    ‚îÇ
‚îÇ                 ‚îÇ     ‚îÇ                 ‚îÇ     ‚îÇ                 ‚îÇ
‚îÇ get_balance()   ‚îÇ     ‚îÇ saldo()         ‚îÇ     ‚îÇ consultar_bal() ‚îÇ
‚îÇ send()          ‚îÇ     ‚îÇ transferir()    ‚îÇ     ‚îÇ enviar()        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚ùå                      ‚ùå                      ‚ùå
    Cada uno diferente - imposible tener c√≥digo gen√©rico


CON TRAITS:
           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚îÇ   Trait Token            ‚îÇ
           ‚îÇ                          ‚îÇ
           ‚îÇ  balance_of() -> i128    ‚îÇ
           ‚îÇ  transfer(...)           ‚îÇ
           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                      ‚ñ≤
                      ‚îÇ implementan
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ            ‚îÇ            ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Token Estable ‚îÇ  ‚îÇ NFT Token ‚îÇ  ‚îÇ DAO Token ‚îÇ
‚îÇ      ‚úÖ       ‚îÇ  ‚îÇ     ‚úÖ    ‚îÇ  ‚îÇ     ‚úÖ    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Resultado: Un DEX puede listar TODOS sin cambios
```

---

## üéØ Mini-ejercicio de reflexi√≥n

**Antes de continuar, reflexiona:**

Imagina que est√°s construyendo un sistema de votaci√≥n. Tienes:
- Propuestas de cambio de ley
- Propuestas de presupuesto
- Propuestas de eventos

Todas necesitan:
- Ver los votos a favor
- Ver los votos en contra
- Determinar si pas√≥ (m√°s del 50%)

**Pregunta:** ¬øC√≥mo dise√±ar√≠as esto con traits?

<details>
<summary>üí° Ver una posible soluci√≥n</summary>

```rust
trait Votable {
    fn votos_a_favor(&self) -> u32;
    fn votos_en_contra(&self) -> u32;
    fn paso(&self) -> bool {
        self.votos_a_favor() > self.votos_en_contra()
    }
}

struct PropuestaLey {
    votos_si: u32,
    votos_no: u32,
    titulo: Symbol,
}

impl Votable for PropuestaLey {
    fn votos_a_favor(&self) -> u32 {
        self.votos_si
    }
    
    fn votos_en_contra(&self) -> u32 {
        self.votos_no
    }
}

// Ahora puedes:
fn contar_aprobadas<T: Votable>(propuestas: Vec<T>) -> u32 {
    propuestas.iter()
        .filter(|p| p.paso())
        .count() as u32
}
```

¬°Nota c√≥mo una sola funci√≥n funciona con CUALQUIER tipo de propuesta!

</details>

---

## ‚úÖ Checklist de conceptos

Antes de pasar a la siguiente secci√≥n, verifica que entiendes:

- [ ] Un trait es un "contrato de comportamiento"
- [ ] Los traits permiten interoperabilidad entre contratos desconocidos
- [ ] En blockchain, los traits son cr√≠ticos para que contratos de diferentes desarrolladores funcionen juntos
- [ ] Ownable es el patr√≥n est√°ndar de control de acceso
- [ ] Las validaciones SIEMPRE van antes de modificar estado
- [ ] Soroban implementa traits autom√°ticamente con sus macros
- [ ] `Address` es una direcci√≥n en blockchain (como billetera/contrato)
- [ ] `Symbol` es texto corto en Soroban (m√°x 32 caracteres)
- [ ] `env.storage()` es la "base de datos" del contrato en blockchain

---

## üí≠ Reflexi√≥n: ¬øPara qu√© te sirve esto?

**Pregunta para ti:**

Si estuvieras construyendo una plataforma de donaciones para 5 ONGs diferentes, ¬øpreferir√≠as:

**A)** Escribir c√≥digo √∫nico para cada ONG (5 implementaciones diferentes, 5 veces el mantenimiento)

**B)** Definir un trait `Donacion` que todas implementen (1 implementaci√≥n base, 5 adaptaciones simples)

La respuesta obvia es B. Y eso es exactamente lo que vas a aplicar en tu tarea.

**Piensa en tu proyecto futuro:**
- ¬øQu√© traits podr√≠as necesitar?
- ¬øQu√© funcionalidades se repiten entre diferentes partes?
- ¬øC√≥mo podr√≠as hacer tu c√≥digo m√°s reutilizable?

---

## üîÑ Conexi√≥n con la siguiente secci√≥n

Ahora que entiendes **C√ìMO** estructurar contratos con traits, necesitas entender **C√ìMO** manejar cuando las cosas salen mal.

En la Parte 2 veremos `Result` y `Option` ‚Äî las herramientas que hacen que tu c√≥digo sea robusto ante errores.

Porque en blockchain, un error puede costar dinero real. Y eso NO es aceptable.

**Spoiler:** Ver√°s c√≥mo `Result` y `Error` trabajan juntos con traits para crear contratos seguros.

---

ü¶à‚ö° **Siguiente:** [02-result-option.md - Result y Option](./02-result-option.md) ‚ö°ü¶à