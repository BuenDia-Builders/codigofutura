# üöÄ PR√ìXIMOS PASOS - Pr√°ctica y Desaf√≠os

## üéØ Objetivo de este documento

Ahora que domin√°s los conceptos fundamentales, es momento de practicar. Aqu√≠ encontrar√°s ejercicios progresivos para consolidar lo aprendido.

**No tengas miedo de romper cosas.** En testnet, todo se puede reiniciar. La mejor forma de aprender es experimentando. ü¶à

---

## üìã Checklist de repaso

Antes de empezar con los ejercicios, asegurate de que entend√©s:

- [ ] La diferencia entre `u32` y `u128`
- [ ] Cu√°ndo usar `Symbol` vs `String`
- [ ] Qu√© significa `mut` y cu√°ndo usarlo
- [ ] La diferencia entre move y copy
- [ ] Qu√© son `&T` y `&mut T`
- [ ] C√≥mo funciona `match` con `Option` y `Result`
- [ ] El patr√≥n leer-modificar-guardar en storage
- [ ] Por qu√© emitimos eventos

**Si alg√∫n punto no est√° claro, volv√© a `02-PASO-A-PASO.md` antes de continuar.**

---

## üéì Nivel 1: Entendiendo el c√≥digo

### Ejercicio 1.1: Lectura de c√≥digo

Lee estas funciones y respond√© las preguntas:

```rust
pub fn mystery_function_a(env: Env) -> u32 {
    let value: u32 = env.storage()
        .instance()
        .get(&symbol_short!("DATA"))
        .unwrap_or(10);
    
    value * 2
}

pub fn mystery_function_b(env: Env, x: u32) {
    let mut current: u32 = env.storage()
        .instance()
        .get(&symbol_short!("TOTAL"))
        .unwrap_or(0);
    
    current += x;
    
    env.storage().instance().set(
        &symbol_short!("TOTAL"),
        &current
    );
}
```

**Preguntas:**
1. ¬øQu√© hace `mystery_function_a`? ¬øModifica el storage?
2. ¬øQu√© valor inicial usa `mystery_function_a` si "DATA" no existe?
3. ¬øQu√© hace `mystery_function_b`? ¬øModifica el storage?
4. ¬øPor qu√© `current` necesita `mut` en `mystery_function_b`?
5. ¬øQu√© pasa si llamamos `mystery_function_b(env, 5)` tres veces seguidas?

<details>
<summary>üëÄ Ver respuestas</summary>

1. **mystery_function_a:** Lee "DATA" del storage y retorna el valor multiplicado por 2. NO modifica el storage (solo lectura).

2. **Valor inicial:** 10 (por el `unwrap_or(10)`)

3. **mystery_function_b:** Lee "TOTAL", le suma `x`, y guarda el nuevo valor. S√ç modifica el storage.

4. **Necesita mut:** Porque hace `current += x`, que modifica la variable.

5. **Llamadas m√∫ltiples:**
   - Primera llamada: 0 + 5 = 5
   - Segunda llamada: 5 + 5 = 10
   - Tercera llamada: 10 + 5 = 15
   - "TOTAL" termina valiendo 15

</details>

---

### Ejercicio 1.2: Detectar errores

Este c√≥digo tiene errores. Encontralos y explic√° por qu√© fallan:

```rust
// ERROR 1
pub fn bad_function_1(env: Env) {
    let contador = 0;
    contador += 1;
    env.storage().instance().set(&symbol_short!("COUNT"), &contador);
}

// ERROR 2
pub fn bad_function_2(env: Env) -> String {
    let s = String::from("hola");
    let s2 = s;
    s
}

// ERROR 3
pub fn bad_function_3(env: Env) {
    let mut x = String::from("test");
    let r1 = &mut x;
    let r2 = &mut x;
    println!("{}, {}", r1, r2);
}
```

<details>
<summary>üëÄ Ver respuestas</summary>

**ERROR 1:**
```rust
let contador = 0;  // ‚ùå Falta `mut`
contador += 1;     // ‚ùå No puede modificar variable inmutable
```
**Soluci√≥n:**
```rust
let mut contador = 0;  // ‚úÖ
```

**ERROR 2:**
```rust
let s2 = s;  // Move: s ya no es v√°lido
s            // ‚ùå Intentando usar s despu√©s del move
```
**Soluci√≥n:**
```rust
s2  // ‚úÖ Retornar s2 en lugar de s
```

**ERROR 3:**
```rust
let r1 = &mut x;
let r2 = &mut x;  // ‚ùå Segunda referencia mutable
```
**Soluci√≥n:** Solo una referencia mutable a la vez. Usar r1 y esperar a que termine antes de crear r2.

</details>

---

## üî® Nivel 2: Modificando el contador

### Ejercicio 2.1: Agregar funci√≥n increment_by

Implement√° una nueva funci√≥n que incremente el contador por una cantidad espec√≠fica:

```rust
pub fn increment_by(env: Env, amount: u32) -> u32 {
    // Tu c√≥digo aqu√≠
    // Debe:
    // 1. Leer el contador actual
    // 2. Sumarle 'amount'
    // 3. Guardar el nuevo valor
    // 4. Emitir evento
    // 5. Retornar el nuevo valor
}
```

**Hint:** Es muy similar a `increment()`, pero en lugar de `+= 1`, us√°s `+= amount`.

<details>
<summary>üí° Ver soluci√≥n</summary>

```rust
pub fn increment_by(env: Env, amount: u32) -> u32 {
    let mut contador: u32 = env.storage()
        .instance()
        .get(&symbol_short!("COUNTER"))
        .unwrap_or(0);
    
    contador += amount;
    
    env.storage().instance().set(
        &symbol_short!("COUNTER"),
        &contador
    );
    
    env.events().publish(
        (symbol_short!("incr_by"),),
        contador
    );
    
    contador
}
```

**Test para tu funci√≥n:**
```rust
#[test]
fn test_increment_by() {
    let env = Env::default();
    let contract_id = env.register_contract(None, ContadorContract);
    let client = ContadorContractClient::new(&env, &contract_id);
    
    assert_eq!(client.increment_by(5), 5);
    assert_eq!(client.increment_by(3), 8);
    assert_eq!(client.get_count(), 8);
}
```

</details>

---

### Ejercicio 2.2: Agregar l√≠mite m√°ximo

Modific√° el contador para que tenga un l√≠mite m√°ximo de 1000:

```rust
pub fn increment(env: Env) -> u32 {
    let mut contador: u32 = env.storage()
        .instance()
        .get(&symbol_short!("COUNTER"))
        .unwrap_or(0);
    
    // AGREGAR: Validaci√≥n de l√≠mite m√°ximo
    // Si contador >= 1000, hacer panic con mensaje apropiado
    
    contador += 1;
    
    env.storage().instance().set(
        &symbol_short!("COUNTER"),
        &contador
    );
    
    env.events().publish(
        (symbol_short!("increment"),),
        contador
    );
    
    contador
}
```

<details>
<summary>üí° Ver soluci√≥n</summary>

```rust
pub fn increment(env: Env) -> u32 {
    let mut contador: u32 = env.storage()
        .instance()
        .get(&symbol_short!("COUNTER"))
        .unwrap_or(0);
    
    // Validaci√≥n de l√≠mite
    if contador >= 1000 {
        panic!("Contador ha alcanzado el m√°ximo de 1000");
    }
    
    contador += 1;
    
    env.storage().instance().set(
        &symbol_short!("COUNTER"),
        &contador
    );
    
    env.events().publish(
        (symbol_short!("increment"),),
        contador
    );
    
    contador
}
```

**Test para validaci√≥n:**
```rust
#[test]
#[should_panic(expected = "m√°ximo de 1000")]
fn test_increment_max_limit() {
    let env = Env::default();
    let contract_id = env.register_contract(None, ContadorContract);
    let client = ContadorContractClient::new(&env, &contract_id);
    
    // Llevar a 1000
    for _ in 0..1000 {
        client.increment();
    }
    
    // Esto debe fallar
    client.increment();
}
```

</details>

---

### Ejercicio 2.3: Funci√≥n set_value

Implement√° una funci√≥n que permita establecer el contador a un valor espec√≠fico:

```rust
pub fn set_value(env: Env, new_value: u32) {
    // Tu c√≥digo aqu√≠
    // Debe:
    // 1. Validar que new_value est√© en rango (0-1000)
    // 2. Guardar el nuevo valor
    // 3. Emitir evento
}
```

**Consideraciones:**
- Valid√° que `new_value` no sea mayor a 1000
- Emit√≠ un evento "set_value" con el nuevo valor

<details>
<summary>üí° Ver soluci√≥n</summary>

```rust
pub fn set_value(env: Env, new_value: u32) {
    // Validaci√≥n
    if new_value > 1000 {
        panic!("Valor debe estar entre 0 y 1000");
    }
    
    // Guardar
    env.storage().instance().set(
        &symbol_short!("COUNTER"),
        &new_value
    );
    
    // Emitir evento
    env.events().publish(
        (symbol_short!("set_val"),),
        new_value
    );
}
```

**Test:**
```rust
#[test]
fn test_set_value() {
    let env = Env::default();
    let contract_id = env.register_contract(None, ContadorContract);
    let client = ContadorContractClient::new(&env, &contract_id);
    
    client.set_value(500);
    assert_eq!(client.get_count(), 500);
    
    client.set_value(0);
    assert_eq!(client.get_count(), 0);
}

#[test]
#[should_panic(expected = "entre 0 y 1000")]
fn test_set_value_invalid() {
    let env = Env::default();
    let contract_id = env.register_contract(None, ContadorContract);
    let client = ContadorContractClient::new(&env, &contract_id);
    
    client.set_value(2000);  // Debe fallar
}
```

</details>

---

## üé® Nivel 3: Proyecto nuevo

### Ejercicio 3.1: Contador con historial

Crea un contador que mantenga historial de los √∫ltimos 5 valores:

**Requisitos:**
1. Usar `Vec<u32>` para almacenar historial
2. Al incrementar/decrementar, agregar el nuevo valor al historial
3. Si el historial tiene m√°s de 5 elementos, remover el m√°s viejo
4. Funci√≥n `get_history()` que retorne el Vec completo

**Estructura b√°sica:**

```rust
#[contract]
pub struct ContadorConHistorial;

#[contractimpl]
impl ContadorConHistorial {
    pub fn increment(env: Env) -> u32 {
        // 1. Leer contador actual
        // 2. Incrementar
        // 3. Leer historial actual
        // 4. Agregar nuevo valor al historial
        // 5. Si historial > 5, remover el primero
        // 6. Guardar contador e historial
        // 7. Retornar nuevo valor
    }
    
    pub fn get_history(env: Env) -> Vec<u32> {
        // Retornar historial del storage
    }
}
```

<details>
<summary>üí° Ver pistas</summary>

**Pistas:**
1. Us√° dos keys diferentes: "COUNT" para el contador, "HIST" para el historial
2. `Vec::new(&env)` crea Vec vac√≠o
3. `vec.push_back(valor)` agrega al final
4. `vec.len()` retorna tama√±o
5. Si `vec.len() > 5`, pod√©s crear un nuevo Vec con los √∫ltimos 5

**Storage:**
```rust
// Leer historial
let mut history: Vec<u32> = env.storage()
    .instance()
    .get(&symbol_short!("HIST"))
    .unwrap_or(Vec::new(&env));

// Agregar nuevo valor
history.push_back(new_value);

// Limitar a 5 elementos (l√≥gica depende de tu implementaci√≥n)

// Guardar historial
env.storage().instance().set(&symbol_short!("HIST"), &history);
```

</details>

---

### Ejercicio 3.2: Sistema de votaci√≥n simple

Crea un contrato de votaci√≥n con dos opciones:

**Requisitos:**
1. Dos contadores: "option_a" y "option_b"
2. Funci√≥n `vote_a(env: Env)` - vota por opci√≥n A
3. Funci√≥n `vote_b(env: Env)` - vota por opci√≥n B
4. Funci√≥n `get_results(env: Env) -> (u32, u32)` - retorna (votos_a, votos_b)
5. Funci√≥n `get_winner(env: Env) -> Symbol` - retorna "A", "B", o "tie"

**Bonus:** Emit√≠ eventos para cada voto.

<details>
<summary>üí° Ver pistas</summary>

**Pistas:**
1. Cada opci√≥n tiene su propia key en storage
2. `vote_b()` es casi id√©ntico a `vote_a()`
3. `get_results()` lee ambas keys y retorna una tupla
4. `get_winner()` compara los valores

</details>

---

## üìö Recursos adicionales

### Para profundizar en Rust

**The Rust Book (Oficial)**
- üìñ URL: https://doc.rust-lang.org/book/
- Cap√≠tulos recomendados:
  - Cap 3: Common Programming Concepts
  - Cap 4: Understanding Ownership ‚≠ê
  - Cap 6: Enums and Pattern Matching

**Rust by Example**
- üìñ URL: https://doc.rust-lang.org/rust-by-example/
- C√≥digo ejecutable que pod√©s modificar

**Rustlings - Ejercicios interactivos**
- üèãÔ∏è URL: https://github.com/rust-lang/rustlings
- Instalaci√≥n: `cargo install rustlings`
- Comando: `rustlings watch`

### Para profundizar en Soroban

**Soroban Learn (Oficial)**
- üìñ URL: https://soroban.stellar.org/docs/learn
- Ejemplos de contratos completos

**Soroban Examples Repository**
- üíª URL: https://github.com/stellar/soroban-examples
- C√≥digo fuente de tokens, NFTs, AMMs

### Herramientas para practicar

**Rust Playground**
- üéÆ URL: https://play.rust-lang.org/
- Prob√° c√≥digo sin instalar nada

**Soroban Testnet**
- üåê URL: https://soroban.stellar.org/docs/getting-started/deploy-to-testnet
- Despleg√° contratos reales en testnet

---

## üó∫Ô∏è Roadmap de pr√°ctica sugerido

### Esta semana (opcional):
- [ ] Completar ejercicios Nivel 1 (Lectura de c√≥digo)
- [ ] Intentar al menos 1 ejercicio del Nivel 2
- [ ] Leer Rust Book Cap√≠tulo 4

### Pr√≥xima semana (opcional):
- [ ] Experimentar con el contador
- [ ] Hacer ejercicios de Rustlings
- [ ] Explorar Soroban Examples

### Cuando tengas m√°s tiempo:
- [ ] Proyecto del Nivel 3
- [ ] Implementar un token simple
- [ ] Desplegar en testnet

---

## ü§î Preguntas frecuentes

### "¬øDebo hacer todos estos ejercicios?"

**No.** Son sugerencias para practicar cuando quieras. No hay obligaci√≥n ni deadline por ahora.

### "¬øCu√°nto tiempo toma dominar ownership?"

Para entenderlo conceptualmente: 1-2 semanas. Para usarlo naturalmente: 1-2 meses de pr√°ctica. Es normal luchar con el compilador al principio.

### "¬øDebo memorizar todas las reglas?"

No. Entend√© los conceptos fundamentales. El compilador te recordar√° las reglas cuando las necesites.

### "¬øQu√© hago si me trabo?"

1. Lee el mensaje de error completo
2. Busc√° el c√≥digo de error en https://doc.rust-lang.org/error-index.html
3. Pregunt√° en Discord
4. No te frustres - es parte del aprendizaje

---

## üéØ Lo m√°s importante

**No hay presi√≥n.** Este material es para que explores a tu ritmo.

Las **tareas obligatorias llegar√°n m√°s adelante** en el curso. Por ahora, disfrut√° experimentando con los conceptos.

**Rust es un marathon, no un sprint.** ü¶à

---

## üìû Canales de soporte

**¬øTe trab√°s en algo?**
- üí¨ Telegram en Consultas: Arrobanos y usa el #rust-ayuda

**¬øQuer√©s compartir tu progreso?**
- üê¶ Twitter: Usa #TiburonasBuilders y [arrobanos](https://x.com/buendiabuilders)

---

## ü¶à Mensaje final

### Lo que lograste hoy

No solo aprendiste sobre Rust. Dominaste conceptos fundamentales que te permiten escribir c√≥digo seguro para blockchain:

‚úÖ Tipos de datos optimizados  
‚úÖ Ownership - seguridad por dise√±o  
‚úÖ Borrowing - eficiencia sin sacrificar seguridad  
‚úÖ Pattern matching - manejar todos los casos  
‚úÖ Storage persistente  
‚úÖ Tests para verificar

**La mayor√≠a de la gente que habla de blockchain no entiende estos conceptos. Vos ahora s√≠.** ü¶à

### El camino del Builder

Como las tiburonas reales:
- **Persistente:** Segu√≠s nadando aunque el compilador te detenga
- **Precisa:** Cada l√≠nea de c√≥digo tiene un prop√≥sito
- **Poderosa:** Domin√°s herramientas que previenen bugs millonarios
- **Pionera:** Est√°s construyendo el futuro

**No te compares con otros.** Compar√° con vos misma de ayer.

### Siguiente paso

La **Clase 4** profundizar√° en Structs y Enums. Vas a dise√±ar estructuras de datos complejas para aplicaciones reales.

**Pero primero:** Disfrut√° haber dominado los fundamentos. Experiment√°. Jug√° con el c√≥digo.

---

ü¶à‚ö° **¬°Vamos a construir, Tiburonas!** ‚ö°ü¶à

**Nos vemos en la Clase 4. Sigue construyendo, sigue nadando.**

---

> üí° **√öltima reflexi√≥n:** Rust no es dif√≠cil porque sea mal dise√±ado. Es dif√≠cil porque te ense√±a a pensar en seguridad desde el d√≠a 1. Esa "dificultad" es en realidad entrenamiento para escribir c√≥digo de producci√≥n de clase mundial.
    let mut to_balance = get_balance(env, to);
    
    from_balance -= amount;
    to_balance += amount;
    
    set_balance(env, from, from_balance);
    set_balance(env, to, to_balance);
}
```

**Preguntas:**
1. ¬øEste c√≥digo compila? ¬øPor qu√© s√≠ o no?
2. Si no compila, ¬øc√≥mo lo arreglar√≠as?
3. ¬øQu√© validaciones faltan?

---

## üìö Recursos adicionales

### Para profundizar en Rust

**The Rust Book (Oficial)**
- üìñ URL: https://doc.rust-lang.org/book/
- Cap√≠tulos recomendados:
  - Cap 3: Common Programming Concepts
  - Cap 4: Understanding Ownership ‚≠ê
  - Cap 6: Enums and Pattern Matching
  - Cap 8: Common Collections

**Rust by Example**
- üìñ URL: https://doc.rust-lang.org/rust-by-example/
- C√≥digo ejecutable que pod√©s modificar y experimentar
- Secciones recomendadas: Ownership, Borrowing, Match

**Rustlings - Ejercicios interactivos**
- üèãÔ∏è URL: https://github.com/rust-lang/rustlings
- Peque√±os ejercicios con retroalimentaci√≥n inmediata
- Instalaci√≥n: `cargo install rustlings`
- Comando: `rustlings watch`

### Para profundizar en Soroban

**Soroban Learn (Oficial)**
- üìñ URL: https://soroban.stellar.org/docs/learn
- Ejemplos de contratos completos
- Mejores pr√°cticas
- Patrones comunes

**Soroban Examples Repository**
- üíª URL: https://github.com/stellar/soroban-examples
- C√≥digo fuente de contratos de ejemplo
- Tokens, NFTs, AMMs, y m√°s
- Perfecto para estudiar c√≥digo real

### Herramientas para practicar

**Rust Playground**
- üéÆ URL: https://play.rust-lang.org/
- Prob√° c√≥digo Rust sin instalar nada
- Compart√≠ snippets con compa√±eras
- Perfecta para experimentar con ownership

**Soroban Testnet**
- üåê URL: https://soroban.stellar.org/docs/getting-started/deploy-to-testnet
- Despleg√° contratos reales en testnet
- Tokens de prueba gratis
- Pr√°ctica en ambiente real

---

## üó∫Ô∏è Roadmap de pr√°ctica

### Semana 1: Fundamentos s√≥lidos
- [ ] Completar ejercicios Nivel 1 (Lectura de c√≥digo)
- [ ] Completar ejercicios Nivel 2 (Modificar contador)
- [ ] Hacer al menos 10 ejercicios de Rustlings
- [ ] Leer Rust Book Cap√≠tulo 4 completo

### Semana 2: Proyectos propios
- [ ] Completar ejercicio 3.1 (Contador con historial)
- [ ] Completar ejercicio 3.2 (Sistema de votaci√≥n)
- [ ] Crear un proyecto original simple
- [ ] Escribir tests para todos tus proyectos

### Semana 3: Profundizaci√≥n
- [ ] Estudiar c√≥digo de Soroban Examples
- [ ] Implementar un token simple (ERC20-like)
- [ ] Desplegar un contrato en testnet
- [ ] Compartir tu c√≥digo con la comunidad

---

## ‚úÖ Checklist de dominio

Antes de avanzar a la Clase 4, verific√° que pod√©s:

### Conceptos b√°sicos
- [ ] Explicar qu√© es `mut` y cu√°ndo usarlo
- [ ] Distinguir entre tipos Copy y Move
- [ ] Elegir entre u32 y u128 apropiadamente
- [ ] Decidir entre Symbol y String en cualquier contexto

### Ownership y Borrowing
- [ ] Explicar las 3 reglas de ownership
- [ ] Predecir cu√°ndo ocurre un move
- [ ] Usar `&T` correctamente para lectura
- [ ] Usar `&mut T` correctamente para modificaci√≥n
- [ ] Entender por qu√© solo puede haber una referencia mutable

### Pattern Matching
- [ ] Usar `match` con enums
- [ ] Manejar `Option<T>` con match y unwrap_or
- [ ] Manejar `Result<T, E>` apropiadamente
- [ ] Escribir validaciones con match y rangos

### Soroban espec√≠fico
- [ ] Leer y escribir en storage
- [ ] Usar `symbol_short!` correctamente
- [ ] Emitir eventos para transparencia
- [ ] Escribir tests con `Env::default()`
- [ ] Validar inputs antes de modificar estado

---

## üéØ Proyecto integrador (Opcional)

### Sistema de reputaci√≥n simple

Implement√° un contrato que permita:

**Funcionalidades:**
1. Los usuarios pueden dar "likes" a una entidad (identificada por Symbol)
2. Los usuarios pueden dar "dislikes" a una entidad
3. Cada usuario solo puede votar una vez por entidad
4. Funciones de consulta: get_likes, get_dislikes, get_score (likes - dislikes)
5. Funci√≥n para ver si un usuario ya vot√≥

**Estructura sugerida:**

```rust
#[contract]
pub struct ReputationContract;

// Necesitar√°s almacenar:
// - Map de (entity, user) -> vote_type
// - Contador de likes por entity
// - Contador de dislikes por entity
```

**Desaf√≠os t√©cnicos:**
- Necesit√°s guardar relaciones usuario-entidad
- Validar que un usuario no vote dos veces
- Manejar m√∫ltiples entidades simult√°neamente

**Hints:**
- Pod√©s usar keys compuestas como `symbol_short!("like_ENT")`
- Para verificar si un usuario vot√≥, intent√° leer su voto del storage
- Us√° Vec para almacenar listas de usuarios si es necesario

<details>
<summary>üí° Ver estructura b√°sica</summary>

```rust
#[contract]
pub struct ReputationContract;

#[contractimpl]
impl ReputationContract {
    pub fn like(env: Env, entity: Symbol, user: Address) {
        // 1. Verificar que el usuario no haya votado
        // 2. Incrementar contador de likes para entity
        // 3. Registrar que user vot√≥ por entity
        // 4. Emitir evento
    }
    
    pub fn dislike(env: Env, entity: Symbol, user: Address) {
        // Similar a like pero para dislikes
    }
    
    pub fn get_likes(env: Env, entity: Symbol) -> u32 {
        // Leer contador de likes para entity
    }
    
    pub fn get_dislikes(env: Env, entity: Symbol) -> u32 {
        // Leer contador de dislikes para entity
    }
    
    pub fn get_score(env: Env, entity: Symbol) -> i32 {
        // likes - dislikes (puede ser negativo, por eso i32)
    }
    
    pub fn has_voted(env: Env, entity: Symbol, user: Address) -> bool {
        // Verificar si user ya vot√≥ por entity
    }
}
```

</details>

---

## ü§î Preguntas frecuentes

### "¬øPor qu√© Rust es tan estricto?"

**Respuesta:** Porque est√° dise√±ado para prevenir bugs que en otros lenguajes solo se descubren en producci√≥n. En blockchain, un bug puede significar p√©rdida de fondos reales. La estrictez es protecci√≥n.

### "¬øCu√°nto tiempo toma dominar ownership?"

**Respuesta:** Para entenderlo conceptualmente: 1-2 semanas. Para usarlo naturalmente: 1-2 meses de pr√°ctica. Es normal que al principio luches con el compilador. Todas pasamos por eso. ü¶à

### "¬øDebo memorizar todas las reglas?"

**Respuesta:** No. Entend√© los conceptos fundamentales. El compilador te recordar√° las reglas espec√≠ficas cuando las necesites. Con pr√°ctica, se vuelve intuitivo.

### "¬øQu√© hago si el compilador me da un error que no entiendo?"

**Respuesta:**
1. Lee el error completo (Rust da explicaciones muy buenas)
2. Busc√° el c√≥digo de error (ej: E0382) en https://doc.rust-lang.org/error-index.html
3. Pregunt√° en Discord con el c√≥digo y el error
4. No te frustres - todos luchamos con el compilador al principio

### "¬øCu√°ndo uso clone() y cu√°ndo borrowing?"

**Respuesta:**
- **Borrowing (`&T`):** Cuando solo necesit√°s leer o modificar temporalmente
- **Clone:** Solo cuando realmente necesit√°s una copia independiente
- En smart contracts, prefer√≠ borrowing por eficiencia
- Clone cuesta gas - usalo conscientemente

### "¬øEs normal que mis primeros contratos sean lentos de escribir?"

**Respuesta:** ¬°Totalmente! Al principio, el compilador te detendr√° mucho. Es parte del aprendizaje. Con pr√°ctica, escribir√°s c√≥digo que compile al primer intento. Rust te entrena a pensar en seguridad desde el inicio.

---

## üéì Autoevaluaci√≥n final

Respond√© estas preguntas sin mirar las notas:

**Parte 1: Conceptos b√°sicos**
1. ¬øCu√°l es la diferencia entre `let x = 5` y `let mut x = 5`?
2. ¬øPor qu√© usar√≠as `u128` en lugar de `u32` para un balance?
3. ¬øCu√°ndo usar√≠as `Symbol` en lugar de `String`?

**Parte 2: Ownership**
4. ¬øQu√© pasa con `s1` despu√©s de `let s2 = s1` si `s1` es un `String`?
5. ¬øPor qu√© `let y = x` no invalida `x` cuando `x` es `u32`?
6. ¬øCu√°les son las 3 reglas de ownership?

**Parte 3: Borrowing**
7. ¬øCu√°l es la diferencia entre `&String` y `&mut String`?
8. ¬øPor qu√© no puedo tener dos `&mut` al mismo tiempo?
9. ¬øCu√°ntas referencias `&` puedo tener simult√°neamente?

**Parte 4: Pattern Matching**
10. ¬øQu√© hace `unwrap_or(0)` en un `Option<u32>`?
11. ¬øCu√°l es la diferencia entre `Option` y `Result`?
12. ¬øPor qu√© `match` es mejor que `if/else` en muchos casos?

**Parte 5: Soroban**
13. ¬øQu√© hace `env.storage().instance().get()`?
14. ¬øPor qu√© emitimos eventos en smart contracts?
15. ¬øQu√© pasa si llam√°s `panic!()` en una funci√≥n?

<details>
<summary>üëÄ Ver respuestas modelo</summary>

**Respuestas:**

1. Sin `mut`, la variable es inmutable (no puede cambiar). Con `mut`, puede modificarse.

2. `u128` puede representar n√∫meros mucho m√°s grandes. Para balances de tokens que pueden tener millones o miles de millones, u128 previene overflow.

3. `Symbol` cuando el texto es fijo y conocido al programar (keys, eventos). `String` cuando el texto viene del usuario o es din√°mico.

4. `s1` se MUEVE a `s2`. `s1` queda inv√°lido y no puede usarse m√°s. Solo `s2` tiene acceso al String.

5. Porque `u32` implementa `Copy`. Los n√∫meros peque√±os se copian autom√°ticamente en lugar de moverse.

6. a) Cada valor tiene un owner. b) Solo un owner a la vez. c) Cuando el owner sale de scope, el valor se destruye.

7. `&String` es solo lectura (referencia inmutable). `&mut String` permite modificar (referencia mutable).

8. Para prevenir data races. Si dos referencias pudieran modificar simult√°neamente, el comportamiento ser√≠a impredecible y peligroso.

9. Infinitas. M√∫ltiples lecturas simult√°neas son seguras - el problema surge cuando alguien escribe mientras otros leen.

10. Si el `Option` es `Some(valor)`, retorna `valor`. Si es `None`, retorna 0 (el valor por defecto).

11. `Option` para valores que pueden no existir. `Result` para operaciones que pueden tener √©xito (`Ok`) o fallar (`Err`) con informaci√≥n del error.

12. `match` fuerza a manejar todos los casos. El compilador verifica que no olvidemos ninguna variante. Con `if/else`, podemos olvidar casos accidentalmente.

13. Intenta leer un valor del storage. Retorna `Option<T>` - `Some(valor)` si existe, `None` si no.

14. Para transparencia (cualquiera puede ver qu√© pas√≥), debugging (rastrear operaciones), y para que frontends puedan reaccionar a cambios en tiempo real.

15. La ejecuci√≥n se detiene inmediatamente. Toda la transacci√≥n revierte (rollback). Ning√∫n cambio de estado se guarda. El usuario recibe el mensaje de error.

</details>

Si respondiste 12+ correctamente: ¬°Domin√°s los fundamentos! ü¶à‚ö°  
Si respondiste 8-11 correctamente: Vas muy bien, repas√° los temas que fallaste.  
Si respondiste menos de 8: Volv√© a `02-PASO-A-PASO.md` y repas√° los conceptos.

---

## ü¶à Mensaje final

### Lo que lograste hoy

No solo aprendiste sintaxis de Rust. Dominaste conceptos fundamentales que te permiten escribir c√≥digo seguro para blockchain:

‚úÖ Tipos de datos optimizados para smart contracts  
‚úÖ Ownership - el sistema √∫nico que hace a Rust seguro por dise√±o  
‚úÖ Borrowing - eficiencia sin sacrificar seguridad  
‚úÖ Pattern matching - manejar todos los casos sin olvidar ninguno  
‚úÖ Storage persistente en blockchain  
‚úÖ Tests para verificar que todo funciona

**Esto no es poca cosa.**

La mayor√≠a de la gente que habla de blockchain no entiende estos conceptos. Vos ahora s√≠.

### El camino del Builder

Como las tiburonas reales:
- **Persistente:** Segu√≠s nadando aunque el compilador te detenga
- **Precisa:** Cada l√≠nea de c√≥digo tiene un prop√≥sito
- **Poderosa:** Domin√°s herramientas que previenen bugs millonarios
- **Pionera:** Est√°s construyendo el futuro de las finanzas

**No te compares con otros.** Compar√° con vos misma de ayer. ¬øSab√≠as m√°s ayer sobre ownership? No. ¬øPod√≠as escribir un contador en Soroban ayer? No. **Est√°s progresando.**

### Siguiente paso

La Clase 4 profundizar√° en Structs y Enums. Vas a dise√±ar estructuras de datos complejas para aplicaciones reales. Con los fundamentos que dominaste hoy, est√°s m√°s que lista.

**Pero primero:** Practic√°. Hac√© los ejercicios. Romp√© cosas. Arreglalas. As√≠ se aprende de verdad.

---

## üìû Canales de soporte

**¬øTe trab√°s en un ejercicio?**
- üìÖ Consultas en vivo: S√°bados

**¬øQuer√©s compartir tu progreso?**
- üê¶ Twitter: Etiqueta #TiburonasBuilders y arrobanos @buendiabuilders
- üì∏ Screenshot de tus tests pasando ‚Üí ¬°celebralo!

**Record√°:** Preguntar no es debilidad. Es inteligencia. Todas las Tiburonas empezamos en el mismo lugar. ü¶à

---

## üéØ Tu compromiso

Antes de la pr√≥xima clase:

- [ ] Completar al menos 5 ejercicios de este documento(de nuevo, no son obligatorios)
- [ ] Escribir tests para todo tu c√≥digo
- [ ] Preguntar en Discord al menos UNA vez (rompe el hielo)
- [ ] Leer Rust Book Cap√≠tulo 4 completo
- [ ] Experimentar con el c√≥digo - romperlo y arreglarlo

**El √©xito no viene de entender todo perfectamente la primera vez.**  
**Viene de practicar, fallar, aprender, y seguir adelante.**

---

ü¶à‚ö° **¬°Vamos a construir!** ‚ö°ü¶à

**Nos vemos en la Clase 4. Sigue construyendo, sigue nadando.**

---

> üí° **√öltima reflexi√≥n:** Rust no es dif√≠cil porque sea mal dise√±ado. Es dif√≠cil porque te ense√±a a pensar en seguridad desde el d√≠a 1. Esa "dificultad" es en realidad entrenamiento para escribir c√≥digo de producci√≥n de clase mundial.
