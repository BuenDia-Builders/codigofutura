# ü¶à Parte 3: Storage Patterns en Soroban
## Donde viven tus datos en la blockchain

**Tiempo estimado:** 22 minutos

---

## üéØ ¬øQu√© vas a entender en esta secci√≥n?

Al final de estos 22 minutos, vas a poder:

- [ ] Explicar los 3 tipos de storage en Soroban
- [ ] Decidir qu√© tipo usar seg√∫n el dato
- [ ] Entender qu√© es TTL y por qu√© importa
- [ ] Usar DataKey enums para organizar storage
- [ ] Reconocer patrones de storage profesional

---

## üíæ El concepto fundamental: Storage en blockchain

### En una app web tradicional:

```
Usuario crea cuenta
    ‚Üì
Datos se guardan en base de datos
    ‚Üì
La base de datos vive en un servidor
    ‚Üì
El servidor lo mantienes t√∫
```

**Costo:** Pagas hosting mensual (fijo)

### En blockchain:

```
Usuario interact√∫a con contrato
    ‚Üì
Datos se guardan en la blockchain
    ‚Üì
La blockchain es distribuida (miles de nodos)
    ‚Üì
Cada nodo guarda una copia
```

**Costo:** Pagas por cada byte guardado (variable)

**Diferencia cr√≠tica:** En blockchain, el storage es CARO. Por eso hay 3 tipos optimizados para diferentes necesidades.

---

## üóÑÔ∏è Los 3 tipos de storage en Soroban

Seg√∫n la [documentaci√≥n oficial de Soroban](https://developers.stellar.org/docs/learn/fundamentals/contract-development/storage/persisting-data), existen tres tipos:

### 1. Instance Storage üì¶
**Para qu√©:** Configuraci√≥n del contrato (global)

```rust
env.storage().instance()
```

**Caracter√≠sticas:**
- ‚úÖ Asociado al contrato completo
- ‚úÖ Dura mientras el contrato est√© activo
- ‚úÖ Costo medio
- ‚úÖ Se extiende con el contrato

**Ejemplos:**
- Direcci√≥n del admin
- Nombre del token
- Configuraci√≥n global
- Contador total de operaciones

**Decisi√≥n:** √ösalo para datos que son "del contrato" no "de usuarios espec√≠ficos"

---

### 2. Persistent Storage üíé
**Para qu√©:** Datos cr√≠ticos que DEBEN persistir

```rust
env.storage().persistent()
```

**Caracter√≠sticas:**
- ‚úÖ Datos espec√≠ficos por usuario
- ‚úÖ Se controla TTL individualmente
- ‚úÖ M√°s caro (datos cr√≠ticos)
- ‚úÖ Requiere extensi√≥n peri√≥dica

**Ejemplos:**
- Balances de usuarios
- Propiedad de NFTs
- Historial de transacciones
- Registros de pr√©stamos

**Decisi√≥n:** √ösalo para datos que representan valor o derechos

---

### 3. Temporary Storage ‚ö°
**Para qu√©:** Datos temporales o cache

```rust
env.storage().temporary()
```

**Caracter√≠sticas:**
- ‚úÖ TTL corto
- ‚úÖ M√°s barato
- ‚úÖ Puede expirar r√°pido
- ‚úÖ Ideal para cache

**Ejemplos:**
- Precios de oracles (se actualizan frecuentemente)
- Locks temporales durante transacciones
- Cache de c√°lculos
- Datos que se recalculan peri√≥dicamente

**Decisi√≥n:** √ösalo para datos que NO son cr√≠ticos y pueden regenerarse

---

## üìä Tabla de decisi√≥n: ¬øQu√© storage usar?

| Tipo de dato | Storage | Raz√≥n |
|--------------|---------|-------|
| Direcci√≥n del admin | Instance | Es configuraci√≥n del contrato |
| Nombre del token | Instance | Metadato global |
| Balance de Mar√≠a | Persistent | Cr√≠tico, espec√≠fico de usuario |
| NFT #123 pertenece a Ana | Persistent | Prueba de propiedad |
| Precio actual de XLM | Temporary | Se actualiza constantemente |
| Lock durante transfer | Temporary | Solo necesario durante operaci√≥n |
| Contador total de donaciones | Instance | Estad√≠stica global |
| √öltima donaci√≥n de Sof√≠a | Persistent | Registro espec√≠fico de usuario |

---

## üîë DataKey Pattern: Organizando el storage

### El problema sin DataKey:

```rust
// ‚ùå MAL: Strings literales por todos lados
pub fn set_admin(env: Env, admin: Address) {
    env.storage().instance().set(&"admin", &admin);
}

pub fn set_balance(env: Env, user: Address, balance: i128) {
    // ‚ùå No se puede hacer esto en Soroban
    let key = format!("balance_{}", user);
    env.storage().persistent().set(&key, &balance);
}

pub fn get_admin(env: Env) -> Address {
    env.storage().instance().get(&"admon")  // ‚ùå TYPO: "admon" vs "admin"
}
```

**Problemas:**

1. **Typos silenciosos:** "admin" vs "admon" ‚Üí bug que el compilador NO detecta
2. **Sin autocomplete:** No sabes qu√© keys existen
3. **Imposible refactorizar:** Cambiar nombres requiere buscar strings en todo el c√≥digo
4. **No documentado:** ¬øQu√© keys usa el contrato? Hay que leer todo el c√≥digo

---

### La soluci√≥n: DataKey Enum

```rust
use soroban_sdk::contracttype;

#[contracttype]
#[derive(Clone)]
pub enum DataKey {
    // Instance storage - configuraci√≥n global
    Admin,
    NombreToken,
    TotalDonaciones,
    
    // Persistent storage - datos de usuarios
    Balance(Address),           // Key compuesta
    UltimaDonacion(Address),    // Key compuesta
    Donacion(u32),              // Key compuesta por ID
}
```

**An√°lisis de decisiones:**

1. **`#[contracttype]`** 
   - Macro de Soroban para tipos en storage
   - Genera c√≥digo de serializaci√≥n autom√°ticamente

2. **`enum` en lugar de constantes**
   - El compilador verifica que uses keys v√°lidas
   - Autocomplete en el IDE
   - Refactoring seguro

3. **Keys simples vs compuestas**
   - `Admin` ‚Üí key simple, un solo valor
   - `Balance(Address)` ‚Üí key compuesta, un valor por direcci√≥n
   - `Donacion(u32)` ‚Üí key compuesta, un valor por ID

---

### Uso del DataKey:

```rust
#[contract]
pub struct PlataformaDonaciones;

#[contractimpl]
impl PlataformaDonaciones {
    // Configuraci√≥n global (Instance)
    pub fn set_admin(env: Env, admin: Address) {
        env.storage()
            .instance()
            .set(&DataKey::Admin, &admin);
    }
    
    pub fn get_admin(env: Env) -> Address {
        env.storage()
            .instance()
            .get(&DataKey::Admin)
            .expect("Admin no inicializado")
    }
    
    // Datos de usuario (Persistent)
    pub fn get_balance(env: Env, usuario: Address) -> i128 {
        env.storage()
            .persistent()
            .get(&DataKey::Balance(usuario))
            .unwrap_or(0)
    }
    
    pub fn set_balance(env: Env, usuario: Address, balance: i128) {
        env.storage()
            .persistent()
            .set(&DataKey::Balance(usuario), &balance);
    }
    
    // Datos indexados (Persistent)
    pub fn guardar_donacion(env: Env, id: u32, donacion: DonacionInfo) {
        env.storage()
            .persistent()
            .set(&DataKey::Donacion(id), &donacion);
    }
    
    pub fn get_donacion(env: Env, id: u32) -> Option<DonacionInfo> {
        env.storage()
            .persistent()
            .get(&DataKey::Donacion(id))
    }
}
```

**Ventajas:**

1. **Type safety:** `DataKey::Admon` ‚Üí Error de compilaci√≥n ‚úÖ
2. **Documentaci√≥n autom√°tica:** Todas las keys visibles en un lugar
3. **Refactoring seguro:** Renombrar `Admin` ‚Üí cambia en todos lados
4. **IDE support:** Autocomplete te muestra todas las keys disponibles

---

## ‚è∞ Time To Live (TTL): La vida de los datos

### ¬øPor qu√© existe el TTL?

En Soroban, el storage NO es eterno por defecto.

**Problema a resolver:**
- Contratos abandonados ocupar√≠an espacio para siempre
- La blockchain crecer√≠a sin l√≠mite
- Costos de mantenimiento ser√≠an insostenibles

**Soluci√≥n:**
- Cada dato tiene un TTL (Time To Live)
- El TTL se mide en ledgers (bloques)
- Si el TTL expira, el dato se borra
- Los contratos activos DEBEN extender el TTL peri√≥dicamente

**Analog√≠a:** Es como renovar una suscripci√≥n. Si no renuevas, pierdes acceso.

---

### Extender TTL: La sintaxis

```rust
env.storage()
    .instance()
    .extend_ttl(threshold, extend_to);
```

**Par√°metros:**

1. **threshold:** "Si quedan menos de N ledgers..."
2. **extend_to:** "...extiende la vida por M ledgers"

**Ejemplo:**

```rust
env.storage()
    .instance()
    .extend_ttl(100, 100);
```

**Significado:**
- "Si quedan menos de 100 ledgers antes de expirar..."
- "...extiende por 100 ledgers m√°s"

**Decisi√≥n:** Valores comunes son 100-200 ledgers (conservative)

---

### Estrategia de TTL: Cu√°ndo extender

#### Opci√≥n 1: Extender en cada operaci√≥n

```rust
pub fn transfer(
    env: Env,
    de: Address,
    para: Address,
    monto: i128
) -> Result<(), Error> {
    // Validaciones...
    
    // Actualizar balances...
    
    // Extender TTL despu√©s de usar los datos
    env.storage()
        .persistent()
        .extend_ttl(&DataKey::Balance(de.clone()), 100, 100);
    
    env.storage()
        .persistent()
        .extend_ttl(&DataKey::Balance(para), 100, 100);
    
    Ok(())
}
```

**Ventajas:**
- ‚úÖ Datos activos nunca expiran
- ‚úÖ Simple de implementar

**Desventajas:**
- ‚ùå Cada operaci√≥n paga por extensi√≥n (m√°s gas)

---

#### Opci√≥n 2: Extender selectivamente

```rust
pub fn transfer(
    env: Env,
    de: Address,
    para: Address,
    monto: i128
) -> Result<(), Error> {
    // Validaciones...
    
    // Actualizar balances...
    
    // Solo extender si est√° cerca de expirar
    let ttl_actual = env.storage()
        .persistent()
        .get_ttl(&DataKey::Balance(de.clone()));
    
    if ttl_actual < 50 {
        env.storage()
            .persistent()
            .extend_ttl(&DataKey::Balance(de), 100, 100);
    }
    
    Ok(())
}
```

**Ventajas:**
- ‚úÖ Ahorra gas (solo extiende cuando necesario)

**Desventajas:**
- ‚ùå M√°s complejo
- ‚ùå Requiere verificaci√≥n adicional

---

#### Decisi√≥n recomendada: Opci√≥n 1 para contratos cr√≠ticos

**Raz√≥n:** 
- Simplicidad > Optimizaci√≥n prematura
- El costo extra de gas es predecible
- No hay riesgo de que datos cr√≠ticos expiren

**Caso de uso:** Token o sistema de donaciones ‚Üí Opci√≥n 1

**Excepci√≥n:** Cache o datos temporales ‚Üí No extender (dejar expirar)

---

## üèóÔ∏è Ejemplo completo: Plataforma de donaciones

```rust
#[contracttype]
#[derive(Clone)]
pub enum DataKey {
    // Instance: Configuraci√≥n del contrato
    Admin,
    NombrePlataforma,
    TotalDonaciones,
    
    // Persistent: Datos cr√≠ticos de usuarios
    BalanceDonante(Address),
    DonacionesRecibidas(Address),  // Total recibido por beneficiaria
    Donacion(u32),                 // Detalle de donaci√≥n por ID
    
    // Temporary: Cache
    CacheTotalDonado,  // Se recalcula cada 100 ledgers
}

#[contracttype]
#[derive(Clone)]
pub struct DonacionInfo {
    pub donante: Address,
    pub beneficiaria: Address,
    pub monto: i128,
    pub timestamp: u64,
}

#[contract]
pub struct PlataformaDonaciones;

#[contractimpl]
impl PlataformaDonaciones {
    // Inicializar (una sola vez)
    pub fn initialize(env: Env, admin: Address, nombre: Symbol) -> Result<(), Error> {
        if env.storage().instance().has(&DataKey::Admin) {
            return Err(Error::YaInicializado);
        }
        
        // Guardar configuraci√≥n global
        env.storage().instance().set(&DataKey::Admin, &admin);
        env.storage().instance().set(&DataKey::NombrePlataforma, &nombre);
        env.storage().instance().set(&DataKey::TotalDonaciones, &0u32);
        
        // Extender TTL de configuraci√≥n
        env.storage().instance().extend_ttl(100, 100);
        
        Ok(())
    }
    
    // Donar (operaci√≥n cr√≠tica)
    pub fn donar(
        env: Env,
        donante: Address,
        beneficiaria: Address,
        monto: i128
    ) -> Result<(), Error> {
        // 1. Validaciones
        donante.require_auth();
        
        if monto <= 0 {
            return Err(Error::MontoInvalido);
        }
        
        // 2. Actualizar balance del donante
        let balance_donante = env.storage()
            .persistent()
            .get(&DataKey::BalanceDonante(donante.clone()))
            .unwrap_or(0);
        
        if balance_donante < monto {
            return Err(Error::BalanceInsuficiente);
        }
        
        env.storage()
            .persistent()
            .set(&DataKey::BalanceDonante(donante.clone()), &(balance_donante - monto));
        
        // 3. Actualizar donaciones recibidas por beneficiaria
        let total_recibido = env.storage()
            .persistent()
            .get(&DataKey::DonacionesRecibidas(beneficiaria.clone()))
            .unwrap_or(0);
        
        env.storage()
            .persistent()
            .set(&DataKey::DonacionesRecibidas(beneficiaria.clone()), &(total_recibido + monto));
        
        // 4. Guardar detalle de donaci√≥n
        let id_donacion: u32 = env.storage()
            .instance()
            .get(&DataKey::TotalDonaciones)
            .unwrap_or(0);
        
        let donacion = DonacionInfo {
            donante: donante.clone(),
            beneficiaria: beneficiaria.clone(),
            monto,
            timestamp: env.ledger().timestamp(),
        };
        
        env.storage()
            .persistent()
            .set(&DataKey::Donacion(id_donacion), &donacion);
        
        // 5. Incrementar contador global
        env.storage()
            .instance()
            .set(&DataKey::TotalDonaciones, &(id_donacion + 1));
        
        // 6. Extender TTL de datos cr√≠ticos
        env.storage()
            .persistent()
            .extend_ttl(&DataKey::BalanceDonante(donante), 100, 100);
        
        env.storage()
            .persistent()
            .extend_ttl(&DataKey::DonacionesRecibidas(beneficiaria), 100, 100);
        
        env.storage()
            .persistent()
            .extend_ttl(&DataKey::Donacion(id_donacion), 100, 100);
        
        // 7. Extender TTL de instance storage
        env.storage().instance().extend_ttl(100, 100);
        
        Ok(())
    }
    
    // Consultas (no modifican estado)
    pub fn get_balance_donante(env: Env, donante: Address) -> i128 {
        env.storage()
            .persistent()
            .get(&DataKey::BalanceDonante(donante))
            .unwrap_or(0)
    }
    
    pub fn get_total_recibido(env: Env, beneficiaria: Address) -> i128 {
        env.storage()
            .persistent()
            .get(&DataKey::DonacionesRecibidas(beneficiaria))
            .unwrap_or(0)
    }
    
    pub fn get_donacion(env: Env, id: u32) -> Option<DonacionInfo> {
        env.storage()
            .persistent()
            .get(&DataKey::Donacion(id))
    }
    
    pub fn get_total_donaciones(env: Env) -> u32 {
        env.storage()
            .instance()
            .get(&DataKey::TotalDonaciones)
            .unwrap_or(0)
    }
}
```

---

## üìä An√°lisis de decisiones de dise√±o

### 1. Separaci√≥n por tipo de storage

```rust
pub enum DataKey {
    // Instance: Configuraci√≥n global
    Admin,
    NombrePlataforma,
    TotalDonaciones,
    
    // Persistent: Datos de usuarios
    BalanceDonante(Address),
    DonacionesRecibidas(Address),
    Donacion(u32),
    
    // Temporary: Cache
    CacheTotalDonado,
}
```

**Decisi√≥n:** Agrupar keys por tipo de storage (comentarios)

**Raz√≥n:** 
- Documentaci√≥n clara
- F√°cil identificar qu√© va en cada storage
- Ayuda en auditor√≠as

---

### 2. Keys compuestas vs simples

```rust
// ‚úÖ Key compuesta - un valor por usuario
BalanceDonante(Address)

// ‚úÖ Key simple - un solo valor global
TotalDonaciones
```

**Decisi√≥n:** Usar keys compuestas para datos por entidad

**Raz√≥n:**
- `Balance(Address)` crea autom√°ticamente claves √∫nicas
- No hay colisi√≥n entre usuarios
- F√°cil de extender (agregar m√°s usuarios sin cambiar estructura)

---

### 3. Orden de operaciones en `donar()`

```rust
pub fn donar(...) -> Result<(), Error> {
    // 1. Validaciones
    // 2. Actualizar balance donante
    // 3. Actualizar balance beneficiaria
    // 4. Guardar detalle
    // 5. Incrementar contador
    // 6. Extender TTL
}
```

**Decisi√≥n:** TTL al final, despu√©s de todas las operaciones

**Raz√≥n:**
- Si una validaci√≥n falla, no se desperdicia gas en TTL
- Solo extender si la operaci√≥n fue exitosa
- M√°s eficiente en gas

---

### 4. Instance vs Persistent para contador

```rust
// Contador global en Instance
env.storage().instance().set(&DataKey::TotalDonaciones, &contador);
```

**Decisi√≥n:** Instance storage para contador global

**Raz√≥n:**
- Es un dato del contrato, no de un usuario espec√≠fico
- Se extiende con el contrato completo (eficiente)
- No necesita TTL individual

**Alternativa (menos eficiente):**
```rust
// ‚ùå Menos eficiente: contador en Persistent
env.storage().persistent().set(&DataKey::TotalDonaciones, &contador);
// Tendr√≠amos que extender TTL espec√≠ficamente para el contador
```

---

### 5. Struct para datos complejos

```rust
#[contracttype]
#[derive(Clone)]
pub struct DonacionInfo {
    pub donante: Address,
    pub beneficiaria: Address,
    pub monto: i128,
    pub timestamp: u64,
}
```

**Decisi√≥n:** Usar struct para agrupar datos relacionados

**Raz√≥n:**
- Una key ‚Üí todos los datos de la donaci√≥n
- M√°s eficiente que m√∫ltiples keys
- F√°cil de serializar/deserializar

**Alternativa (menos eficiente):**
```rust
// ‚ùå M√∫ltiples keys para una donaci√≥n
DataKey::DonacionDonante(u32)
DataKey::DonacionBeneficiaria(u32)
DataKey::DonacionMonto(u32)
DataKey::DonacionTimestamp(u32)
// 4 lecturas/escritas vs 1
```

---

## üéØ Patrones avanzados de storage

### Patr√≥n 1: Lazy initialization

```rust
pub fn get_balance(env: Env, usuario: Address) -> i128 {
    env.storage()
        .persistent()
        .get(&DataKey::Balance(usuario))
        .unwrap_or(0)  // Si no existe, devuelve 0 (inicializaci√≥n perezosa)
}
```

**Ventaja:** No necesitas inicializar expl√≠citamente cada usuario

---

### Patr√≥n 2: Verificaci√≥n de existencia

```rust
pub fn usuario_existe(env: Env, usuario: Address) -> bool {
    env.storage()
        .persistent()
        .has(&DataKey::Balance(usuario))
}
```

**Decisi√≥n:** Usar `has()` en lugar de `get()`

**Raz√≥n:** M√°s barato (no deserializa el valor, solo verifica existencia)

---

### Patr√≥n 3: Datos relacionados

```rust
pub fn eliminar_usuario(env: Env, usuario: Address) -> Result<(), Error> {
    // Eliminar todos los datos relacionados
    env.storage().persistent().remove(&DataKey::Balance(usuario.clone()));
    env.storage().persistent().remove(&DataKey::UltimaDonacion(usuario.clone()));
    env.storage().persistent().remove(&DataKey::TotalDonado(usuario));
    
    Ok(())
}
```

**Decisi√≥n:** Eliminar datos relacionados juntos

**Raz√≥n:** Evitar datos hu√©rfanos, mantener consistencia

---

## ‚úÖ Mejores pr√°cticas de storage

### DO (Hacer) ‚úÖ

1. **Usa DataKey enums**
   ```rust
   #[contracttype]
   pub enum DataKey { ... }
   ```

2. **Extiende TTL en operaciones cr√≠ticas**
   ```rust
   env.storage().persistent().extend_ttl(&key, 100, 100);
   ```

3. **Instance para configuraci√≥n global**
   ```rust
   env.storage().instance().set(&DataKey::Admin, &admin);
   ```

4. **Persistent para datos de usuarios**
   ```rust
   env.storage().persistent().set(&DataKey::Balance(user), &balance);
   ```

5. **Temporary para cache**
   ```rust
   env.storage().temporary().set(&DataKey::CachePrice, &price);
   ```

### DON'T (No hacer) ‚ùå

1. **No uses strings literales**
   ```rust
   // ‚ùå MAL
   env.storage().instance().set(&"admin", &admin);
   ```

2. **No olvides extend_ttl**
   ```rust
   // ‚ùå MAL: guardar sin extender TTL
   env.storage().persistent().set(&key, &value);
   // Los datos pueden expirar
   ```

3. **No uses Persistent para todo**
   ```rust
   // ‚ùå MAL: cache en persistent (caro)
   env.storage().persistent().set(&DataKey::Cache, &value);
   ```

4. **No mezcles tipos de storage arbitrariamente**
   ```rust
   // ‚ùå Confuso: mismo dato en diferentes storages
   env.storage().instance().set(&DataKey::Balance(user), &balance);
   // M√°s tarde...
   env.storage().persistent().set(&DataKey::Balance(user), &balance);
   ```

---

## ‚úÖ Checklist de conceptos

Antes de pasar a la siguiente secci√≥n, verifica que entiendes:

- [ ] Los 3 tipos de storage: Instance, Persistent, Temporary
- [ ] Instance = configuraci√≥n global, Persistent = datos de usuarios
- [ ] TTL debe extenderse peri√≥dicamente
- [ ] DataKey enum organiza y hace type-safe el storage
- [ ] Keys compuestas permiten datos por entidad
- [ ] Extender TTL despu√©s de operaciones exitosas

---

## üí≠ Reflexi√≥n: El costo del storage

**Pregunta para ti:**

Si tienes 10,000 usuarios, cada uno con:
- Balance
- √öltima donaci√≥n
- Historial de 100 transacciones

¬øPrefieres:

**A)** Guardar TODO en Persistent (seguro pero caro)

**B)** Balance en Persistent, historial en Temporary (balance cr√≠tico, historial regenerable)

La respuesta depende de tu caso de uso. Pero ahora tienes las herramientas para decidir.

---

## üîÑ Conexi√≥n con la siguiente secci√≥n

Ya entiendes:
- ‚úÖ Traits (c√≥mo estructurar contratos)
- ‚úÖ Result/Option (c√≥mo manejar errores)
- ‚úÖ Storage (d√≥nde guardar datos)

Ahora veremos C√ìMO todo esto se junta en un contrato completo y profesional.

En la Parte 4 analizaremos el Hello World mejorado ‚Äî l√≠nea por l√≠nea, decisi√≥n por decisi√≥n.

---

ü¶à‚ö° **Siguiente:** [04-ejemplo-completo.md - Hello World Mejorado](./04-ejemplo-completo.md) ‚ö°ü¶à