# üíª C√ìDIGO EXPLICADO - Contador en Soroban (Clase 3)

## üéØ Objetivo de este documento

¬°Tiburona! Aqu√≠ vas a ver el contador completo que construimos en clase, explicado bloque por bloque. No es un c√≥digo denso que ten√©s que copiar sin entender - es una gu√≠a para que entiendas cada decisi√≥n y te sientas segura modific√°ndolo.

**Este contador demuestra TODOS los conceptos que aprendiste:**
- Tipos optimizados (u32, Symbol)
- Storage persistente en blockchain
- Borrowing en las funciones
- Option en lectura de storage
- Pattern matching en validaciones
- Eventos para transparencia

---

## üìñ Glosario de t√©rminos clave

Antes de empezar, ac√° est√°n los t√©rminos t√©cnicos que vas a ver. No te preocupes si algunos suenan raros - los vas a entender mejor cuando los veas en acci√≥n.

| T√©rmino | Significado Simple | Analog√≠a |
|---------|-------------------|----------|
| **no_std** | No usar la biblioteca est√°ndar de Rust | Como cocinar sin electrodom√©sticos - solo lo esencial |
| **Symbol** | Identificador eficiente para keys | Como usar "CTR" en lugar de "CONTADOR" - m√°s corto, m√°s barato |
| **Option** | Un valor que puede existir o no | Como abrir una caja: puede tener algo (Some) o estar vac√≠a (None) |
| **panic!** | Detener todo inmediatamente con error | Como el bot√≥n de emergencia que para la m√°quina |
| **borrowing** | Prestar sin dar la propiedad | Como prestar tu libro sin regalarlo |
| **underflow** | Restar m√°s de lo que hay | Intentar sacar $100 de una cuenta con $50 |
| **rollback** | Deshacer todos los cambios | Como Ctrl+Z cuando algo sale mal |
| **WASM** | C√≥digo optimizado para blockchain | Como comprimir un archivo antes de enviarlo |
| **mut** | Variable que puede cambiar | Como un cuaderno donde pod√©s borrar y reescribir |
| **instance storage** | Almacenamiento con duraci√≥n media | Como guardar en tu disco duro (no RAM, no eterno) |

---

## üìã Estructura completa del contador

El contador es un smart contract que:
1. ‚úÖ Mantiene un n√∫mero en storage (persistente)
2. ‚úÖ Puede incrementar ese n√∫mero
3. ‚úÖ Puede decrementar (con validaciones)
4. ‚úÖ Puede resetear a cero
5. ‚úÖ Permite consultar el valor actual
6. ‚úÖ Emite eventos para cada operaci√≥n

---

## üîß Bloque 1: Setup inicial

```rust
#![no_std]

use soroban_sdk::{
    contract,
    contractimpl,
    Env,
    Symbol,
    symbol_short!,
};
```

### ¬øQu√© hace cada l√≠nea?

**`#![no_std]`**
- Dice "no usar la biblioteca est√°ndar de Rust"
- La std incluye threads, filesystem, networking
- Nada de eso existe en blockchain
- Soroban provee todo lo necesario

> üí° **Analog√≠a:** Es como empacar solo lo esencial para un viaje en avi√≥n. No pod√©s llevar tu heladera, tu cama y tu escritorio. Solo llev√°s lo que cabe en la valija y lo que realmente necesit√°s.

**`use soroban_sdk::{...}`**
- `contract`: Macro para marcar structs como contratos
- `contractimpl`: Macro para exponer m√©todos como funciones p√∫blicas
- `Env`: Ambiente - tu interfaz con la blockchain
- `Symbol` y `symbol_short!`: Para identificadores eficientes

> üí° **Piensa en Env como:** Tu caja de herramientas. Tiene todo lo que necesit√°s para interactuar con la blockchain: storage, eventos, informaci√≥n del contexto.

---

## üóÇÔ∏è Bloque 2: Definici√≥n del contrato

```rust
#[contract]
pub struct ContadorContract;
```

### ¬øQu√© significa esto?

**`#[contract]`**
- Marca este struct como un smart contract
- El SDK de Soroban lo transforma en c√≥digo WASM
- Es como poner una etiqueta que dice "esto es un contrato inteligente"

**`pub struct ContadorContract;`**
- El struct est√° vac√≠o (sin campos)
- Solo sirve como contenedor
- Las funciones reales van en el `impl`

> üí° **Analog√≠a:** Es como el nombre de tu negocio. "Panader√≠a Mar√≠a" no dice qu√© vend√©s exactamente, pero las funciones adentro (hornear, vender, cobrar) s√≠ definen qu√© hace tu negocio.

---

## ‚ö° Bloque 3: Funci√≥n increment

```rust
#[contractimpl]
impl ContadorContract {
    
    pub fn increment(env: Env) -> u32 {
        // PASO 1: Leer del storage
        let mut contador: u32 = env.storage()
            .instance()
            .get(&symbol_short!("COUNTER"))
            .unwrap_or(0);
        
        // PASO 2: Incrementar
        contador += 1;
        
        // PASO 3: Guardar en storage
        env.storage().instance().set(
            &symbol_short!("COUNTER"),
            &contador
        );
        
        // PASO 4: Emitir evento
        env.events().publish(
            (symbol_short!("increment"),),
            contador
        );
        
        // PASO 5: Retornar
        contador
    }
}
```

### Explicaci√≥n paso a paso

#### Firma de la funci√≥n
```rust
pub fn increment(env: Env) -> u32
```

- **`pub`**: Funci√≥n p√∫blica (llamable desde fuera)
- **`fn increment`**: Nombre de la funci√≥n
- **`env: Env`**: Ambiente de Soroban (SIEMPRE primer par√°metro)
- **`-> u32`**: Retorna un n√∫mero u32

#### PASO 1: Leer del storage

```rust
let mut contador: u32 = env.storage()
    .instance()
    .get(&symbol_short!("COUNTER"))
    .unwrap_or(0);
```

**Desglose completo:**

1. **`env.storage()`** ‚Üí Acceder al storage del contrato
2. **`.instance()`** ‚Üí Usar storage de tipo "instance" (duraci√≥n media)
3. **`.get(&symbol_short!("COUNTER"))`** ‚Üí Buscar la key "COUNTER"
   - Retorna `Option<u32>`
   - `Some(valor)` si existe
   - `None` si no existe
4. **`.unwrap_or(0)`** ‚Üí Si es `None`, usar 0
   - Primera llamada: key no existe ‚Üí usa 0
   - Llamadas posteriores: obtiene el valor guardado

> üí° **Analog√≠a del Option:** Es como buscar en tu heladera. Abr√≠s (get), mir√°s si hay yogurt (Option). Si hay ‚Üí Some(yogurt). Si no hay ‚Üí None. Con unwrap_or(0) dec√≠s "si no hay yogurt, asum√≠ que tengo 0 yogures".

**¬øPor qu√© `unwrap_or(0)`?**

En smart contracts, un contador no inicializado se asume como 0. Esto simplifica la l√≥gica - no necesitamos manejar `None` expl√≠citamente con match.

**¬øPor qu√© `mut`?**

Necesitamos `mut` porque vamos a incrementar el contador en el siguiente paso. Sin `mut`, el compilador no permitir√≠a `contador += 1`.

> üí° **Analog√≠a del mut:** Es como la diferencia entre un cuaderno (mut - pod√©s escribir y borrar) vs. un libro impreso (inmutable - solo leer).

**¬øPor qu√© `&symbol_short!("COUNTER")`?**

- `symbol_short!("COUNTER")` crea un Symbol
- El `&` crea una referencia a ese Symbol
- `get()` necesita una referencia (borrowing)

> üí° **Analog√≠a del borrowing:** Es como cuando tu amiga te pide prestado un libro. Le das el libro (referencia &) pero sigue siendo tuyo. No se lo regal√°s (no transfiere ownership).

#### PASO 2: Incrementar

```rust
contador += 1;
```

- Sintaxis de Rust para `contador = contador + 1`
- En debug mode, si hay overflow, causa panic
- Para producci√≥n cr√≠tica, considerar√≠amos `contador.checked_add(1)`

> ‚ö†Ô∏è **Overflow significa:** Si ten√©s un u32 en su valor m√°ximo (4,294,967,295) y le sum√°s 1, se vuelve 0. Como el cuentakil√≥metros de un auto que da la vuelta.

#### PASO 3: Guardar en storage

```rust
env.storage().instance().set(
    &symbol_short!("COUNTER"),
    &contador
);
```

**Desglose:**

1. **`env.storage().instance()`** ‚Üí Mismo storage que antes
2. **`.set(key, value)`** ‚Üí Guardar key-value
3. **`&symbol_short!("COUNTER")`** ‚Üí La key (referencia)
4. **`&contador`** ‚Üí El valor (referencia)

**¬øPor qu√© referencias?**

`set()` toma referencias para no consumir los valores. Usamos borrowing para eficiencia - no necesitamos mover/copiar.

> üí° **Piensa en set() como:** Guardar un archivo en tu computadora. Le pas√°s el nombre del archivo (key) y el contenido (value), pero tu variable `contador` sigue existiendo en tu c√≥digo.

#### PASO 4: Emitir evento

```rust
env.events().publish(
    (symbol_short!("increment"),),
    contador
);
```

**Desglose:**

1. **`env.events().publish(...)`** ‚Üí Publicar evento
2. **Primer argumento:** Topics (tupla de Symbols)
   - `(symbol_short!("increment"),)` ‚Üí Tupla de 1 elemento
   - La coma es necesaria para que Rust lo reconozca como tupla
3. **Segundo argumento:** Data del evento
   - `contador` ‚Üí El nuevo valor

**¬øPor qu√© eventos?**

- **Transparencia:** Cualquiera puede ver el historial
- **Debugging:** Facilita rastrear comportamiento
- **Frontends:** Apps web pueden reaccionar a eventos en tiempo real

> üí° **Analog√≠a de eventos:** Es como cuando hac√©s una compra con tarjeta. El banco registra (emite evento): "Compra en Supermercado X, $500". Vos, el banco, y la AFIP pueden ver ese registro. Transparencia total.

#### PASO 5: Retornar

```rust
contador
```

- Sin punto y coma = retorno impl√≠cito
- Equivalente a `return contador;`
- Estilo idiom√°tico de Rust

> üí° **Dato curioso:** En Rust, la √∫ltima expresi√≥n sin `;` es el valor de retorno. Es elegante y limpio.

---

## ‚¨áÔ∏è Bloque 4: Funci√≥n decrement

```rust
pub fn decrement(env: Env) -> u32 {
    let mut contador: u32 = env.storage()
        .instance()
        .get(&symbol_short!("COUNTER"))
        .unwrap_or(0);
    
    // VALIDACI√ìN CR√çTICA
    if contador == 0 {
        panic!("No se puede decrementar: contador ya est√° en 0");
    }
    
    contador -= 1;
    
    env.storage().instance().set(
        &symbol_short!("COUNTER"),
        &contador
    );
    
    env.events().publish(
        (symbol_short!("decrement"),),
        contador
    );
    
    contador
}
```

### La parte nueva: Validaci√≥n

```rust
if contador == 0 {
    panic!("No se puede decrementar: contador ya est√° en 0");
}
```

**¬øPor qu√© esta validaci√≥n?**

1. **Prevenir underflow:**
   - u32 no puede ser negativo
   - 0 - 1 causar√≠a wrap-around (se vuelve u32::MAX = 4,294,967,295)
   - Esto ser√≠a un bug grave

> üí° **Analog√≠a del underflow:** Es como tu cuenta bancaria. No pod√©s tener -$100. Si intent√°s sacar m√°s de lo que ten√©s, el banco te rechaza la operaci√≥n. Ac√° hacemos lo mismo.

2. **`panic!` en smart contracts:**
   - Detiene la ejecuci√≥n inmediatamente
   - Toda la transacci√≥n revierte (rollback)
   - Ning√∫n cambio de estado se guarda
   - El usuario recibe el mensaje de error

> üí° **Analog√≠a del panic!:** Es como cuando detect√°s humo en tu cocina y presion√°s el bot√≥n de emergencia. Todo se detiene. No se guarda la comida a medio hacer, no se cobra el pedido. Todo vuelve al estado anterior.

3. **Validar ANTES de modificar:**
   - Leemos el contador
   - Verificamos si es seguro decrementar
   - Solo si es seguro, procedemos
   - Principio: "fail fast" (fallar r√°pido)

**Lecci√≥n:** En blockchain, valid√° inputs ANTES de modificar estado. Si algo est√° mal, revert√≠ todo. Nunca dejes el estado inconsistente.

> ‚ö†Ô∏è **Regla de oro en blockchain:** Validar ‚Üí Ejecutar ‚Üí Emitir. En ese orden. Siempre.

---

## üëÅÔ∏è Bloque 5: Funci√≥n get_count

```rust
pub fn get_count(env: Env) -> u32 {
    env.storage()
        .instance()
        .get(&symbol_short!("COUNTER"))
        .unwrap_or(0)
}
```

### ¬øPor qu√© es m√°s simple?

Esta funci√≥n es solo lectura - no modifica nada:

1. **No necesita `mut`:**
   - No modifica ninguna variable
   - Solo lee y retorna

2. **Es m√°s barata:**
   - Solo lectura consume menos gas
   - No escribe en storage
   - Los usuarios pueden llamarla sin costo (query)

> üí° **Analog√≠a de queries:** Es como mirar el precio en una vidriera vs. entrar a comprar. Mirar es gratis y r√°pido. Comprar (escribir en blockchain) cuesta gas y toma tiempo.

3. **Retorno directo:**
   - No necesita variable intermedia
   - Lee y retorna en una expresi√≥n

**Lecci√≥n:** Las funciones de solo lectura son m√°s simples y baratas. Us√° este patr√≥n siempre que solo necesites consultar datos.

---

## üîÑ Bloque 6: Funci√≥n reset

```rust
pub fn reset(env: Env) {
    env.storage().instance().set(
        &symbol_short!("COUNTER"),
        &0u32
    );
    
    env.events().publish(
        (symbol_short!("reset"),),
        0u32
    );
}
```

### Detalles importantes

**Sin tipo de retorno:**
```rust
pub fn reset(env: Env) {
    // Tipo de retorno impl√≠cito: () (unit type - como void)
```

- Operaci√≥n de efecto lateral (modifica estado)
- No hay valor significativo que retornar

> üí° **Analog√≠a:** Es como presionar "borrar todo" en tu calculadora. La acci√≥n se ejecuta, pero no te devuelve ning√∫n n√∫mero. Solo resetea.

**`&0u32` en lugar de variable:**
```rust
env.storage().instance().set(
    &symbol_short!("COUNTER"),
    &0u32  // ‚òùÔ∏è Referencia al literal 0
);
```

- Pasamos referencia directa al literal
- `u32` especifica el tipo (sin ambig√ºedad)
- No necesitamos crear una variable intermedia

**Evento con valor fijo:**
```rust
env.events().publish(
    (symbol_short!("reset"),),
    0u32  // Siempre publicamos 0
);
```

Indica que el reset ocurri√≥ y el nuevo valor es 0.

---

## üß™ Bloque 7: Tests

```rust
#[cfg(test)]
mod test {
    use super::*;
    use soroban_sdk::Env;
    
    #[test]
    fn test_increment() {
        // ARRANGE: Preparar
        let env = Env::default();
        let contract_id = env.register_contract(None, ContadorContract);
        let client = ContadorContractClient::new(&env, &contract_id);
        
        // ACT & ASSERT: Ejecutar y verificar
        assert_eq!(client.increment(), 1);
        assert_eq!(client.increment(), 2);
        assert_eq!(client.get_count(), 2);
    }
    
    #[test]
    fn test_decrement() {
        let env = Env::default();
        let contract_id = env.register_contract(None, ContadorContract);
        let client = ContadorContractClient::new(&env, &contract_id);
        
        // Incrementar primero
        client.increment();
        client.increment();
        client.increment();
        
        // Decrementar
        assert_eq!(client.decrement(), 2);
        assert_eq!(client.get_count(), 2);
    }
    
    #[test]
    #[should_panic(expected = "contador ya est√° en 0")]
    fn test_decrement_panic() {
        let env = Env::default();
        let contract_id = env.register_contract(None, ContadorContract);
        let client = ContadorContractClient::new(&env, &contract_id);
        
        // Esto DEBE causar panic
        client.decrement();
    }
    
    #[test]
    fn test_reset() {
        let env = Env::default();
        let contract_id = env.register_contract(None, ContadorContract);
        let client = ContadorContractClient::new(&env, &contract_id);
        
        client.increment();
        client.increment();
        client.reset();
        
        assert_eq!(client.get_count(), 0);
    }
}
```

### Entendiendo los tests

> üí° **¬øPor qu√© testear?** En blockchain, un bug puede costar dinero real. Los tests son tu red de seguridad. Si algo se rompe, lo descubr√≠s ac√°, no en producci√≥n.

#### Setup de cada test

```rust
let env = Env::default();
let contract_id = env.register_contract(None, ContadorContract);
let client = ContadorContractClient::new(&env, &contract_id);
```

**¬øQu√© hace cada l√≠nea?**

1. **`Env::default()`**
   - Crea ambiente de testing
   - Simula blockchain completa en memoria
   - Storage aislado (no afecta otros tests)

> üí° **Analog√≠a:** Es como un simulador de vuelo. Pod√©s practicar aterrizar sin riesgo. Ac√° pod√©s probar tu contrato sin gastar gas real.

2. **`env.register_contract(...)`**
   - Registra nuestro contrato
   - `None`: genera ID autom√°tico
   - `ContadorContract`: nuestro struct
   - Retorna: `contract_id` para invocar funciones

3. **`ContadorContractClient::new(...)`**
   - Crea cliente para llamar funciones
   - El SDK genera autom√°ticamente este tipo
   - Sufijo `Client` se agrega al nombre del struct

**¬øDe d√≥nde sale `ContadorContractClient`?**

El SDK de Soroban lo genera autom√°ticamente cuando us√°s `#[contract]` y `#[contractimpl]`. Es "magia" del macro - no lo escrib√≠s vos.

> üí° **Testing vs. Producci√≥n:** En tests, todo es simulado y gratis. En la red real (testnet/mainnet), cada operaci√≥n cuesta gas y se guarda permanentemente. ¬°Practica aqu√≠, perfecciona all√°!

#### Test b√°sico: test_increment

```rust
#[test]
fn test_increment() {
    // Setup
    let env = Env::default();
    let contract_id = env.register_contract(None, ContadorContract);
    let client = ContadorContractClient::new(&env, &contract_id);
    
    // Verificaciones
    assert_eq!(client.increment(), 1);
    assert_eq!(client.increment(), 2);
    assert_eq!(client.get_count(), 2);
}
```

**¬øQu√© verifica?**
1. Primera llamada a `increment()` retorna 1
2. Segunda llamada retorna 2
3. `get_count()` confirma que el valor es 2

**Si algo falla:**
- `assert_eq!` causa panic con mensaje descriptivo
- El test falla y ves exactamente qu√© sali√≥ mal

> üí° **Estructura AAA:** Arrange (preparar), Act (ejecutar), Assert (verificar). Patr√≥n universal en testing.

#### Test con should_panic

```rust
#[test]
#[should_panic(expected = "contador ya est√° en 0")]
fn test_decrement_panic() {
    let env = Env::default();
    let contract_id = env.register_contract(None, ContadorContract);
    let client = ContadorContractClient::new(&env, &contract_id);
    
    client.decrement();  // Esperamos que esto cause panic
}
```

**¬øC√≥mo funciona?**

- **`#[should_panic]`**: Este test PASA si hay panic
- **`expected = "..."`**: Verifica que el mensaje sea correcto
- Si NO hay panic ‚Üí el test FALLA
- Si hay panic con otro mensaje ‚Üí el test FALLA
- Si hay panic con este mensaje exacto ‚Üí el test PASA ‚úÖ

> üí° **Testing negativo:** No solo prob√°s que las cosas funcionen. Tambi√©n prob√°s que fallen correctamente cuando deben fallar. ¬°Esto es ser una Tiburona profesional!

**Lecci√≥n:** Pod√©s (y deb√©s) testear que las validaciones funcionen correctamente.

---

## üöÄ Compilar y ejecutar

### Compilar el contrato

```bash
stellar contract build
```

**¬øQu√© hace?**
- Compila el c√≥digo Rust a WASM
- Genera: `target/wasm32-unknown-unknown/release/nombre_contrato.wasm`
- Optimiza para tama√±o (importante en blockchain)

> üí° **WASM es como:** Comprimir un video antes de subirlo a YouTube. Mismo contenido, mucho m√°s peque√±o y eficiente.

### Ejecutar tests

```bash
# Todos los tests
cargo test

# Con output detallado
cargo test -- --nocapture

# Test espec√≠fico
cargo test test_increment
```

**Interpretando output:**

```
running 4 tests
test test::test_decrement ... ok
test test::test_decrement_panic ... ok
test test::test_increment ... ok
test test::test_reset ... ok

test result: ok. 4 passed; 0 failed
```

- **`ok`**: Test pas√≥ correctamente ‚úÖ
- **`FAILED`**: Test fall√≥ ‚ùå
- Resumen final: cu√°ntos pasaron/fallaron

> üí° **Pro tip:** Ejecut√° `cargo test` antes de cada commit. Si algo se rompe, lo descubr√≠s inmediatamente.

---

## üéØ Conceptos aplicados en el c√≥digo

### Tipos de datos
- ‚úÖ **u32** para el contador (eficiente, suficiente)
- ‚úÖ **Symbol** para keys ("COUNTER") y eventos
- ‚úÖ Notaci√≥n con guiones bajos para legibilidad

### Mutabilidad
- ‚úÖ **`mut`** en variables que se modifican
- ‚úÖ Inmutabilidad por defecto en funciones de lectura

### Borrowing
- ‚úÖ Referencias (`&`) en storage operations
- ‚úÖ No copiamos valores innecesariamente

### Option
- ‚úÖ `get()` retorna `Option<u32>`
- ‚úÖ `unwrap_or(0)` para valor por defecto

### Pattern matching (impl√≠cito)
- ‚úÖ En `unwrap_or()` (maneja Some/None)
- ‚úÖ En validaciones con `if`

### Storage persistente
- ‚úÖ `env.storage().instance()` para datos persistentes
- ‚úÖ `get()` para leer, `set()` para escribir

### Eventos
- ‚úÖ `env.events().publish()` para transparencia
- ‚úÖ Topics con Symbol, data con valores

### Tests
- ‚úÖ Estructura AAA (Arrange, Act, Assert)
- ‚úÖ Tests positivos y negativos
- ‚úÖ `should_panic` para validaciones

---

## üìä Flujo completo de una transacci√≥n

### Ejemplo: Usuario llama `increment()`

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   USUARIO   ‚îÇ    ‚îÇ  CONTRATO   ‚îÇ    ‚îÇ   STORAGE   ‚îÇ    ‚îÇ   EVENTO    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
      ‚îÇ                   ‚îÇ                   ‚îÇ                   ‚îÇ
      ‚îÇ                   ‚îÇ                   ‚îÇ                   ‚îÇ
      ‚îÇ‚îÄ‚îÄ‚îÄ increment() ‚îÄ‚îÄ>‚îÇ                   ‚îÇ                   ‚îÇ
      ‚îÇ                   ‚îÇ                   ‚îÇ                   ‚îÇ
      ‚îÇ                   ‚îÇ‚îÄ‚îÄ get(COUNTER) ‚îÄ‚îÄ>‚îÇ                   ‚îÇ
      ‚îÇ                   ‚îÇ<‚îÄ‚îÄ‚îÄ Some(5) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                   ‚îÇ
      ‚îÇ                   ‚îÇ                   ‚îÇ                   ‚îÇ
      ‚îÇ                   ‚îÇ contador = 5      ‚îÇ                   ‚îÇ
      ‚îÇ                   ‚îÇ contador += 1     ‚îÇ                   ‚îÇ
      ‚îÇ                   ‚îÇ contador = 6      ‚îÇ                   ‚îÇ
      ‚îÇ                   ‚îÇ                   ‚îÇ                   ‚îÇ
      ‚îÇ                   ‚îÇ‚îÄ set(COUNTER, 6)‚îÄ>‚îÇ                   ‚îÇ
      ‚îÇ                   ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ OK ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                   ‚îÇ
      ‚îÇ                   ‚îÇ                   ‚îÇ                   ‚îÇ
      ‚îÇ                   ‚îÇ‚îÄ‚îÄ‚îÄ publish(increment, 6) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ
      ‚îÇ                   ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ OK ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
      ‚îÇ                   ‚îÇ                   ‚îÇ                   ‚îÇ
      ‚îÇ<‚îÄ‚îÄ retorna 6 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                   ‚îÇ                   ‚îÇ
      ‚îÇ                   ‚îÇ                   ‚îÇ                   ‚îÇ
```

**Puntos clave:**
1. **Lectura de storage** (puede ser None)
2. **L√≥gica de negocio** (incrementar)
3. **Escritura a storage** (persistir)
4. **Emisi√≥n de evento** (transparencia)
5. **Retorno al usuario**

**Si algo falla:** Todo revierte. El storage no cambia.

> üí° **Atomicidad:** En blockchain, las transacciones son todo-o-nada. Como depositar un cheque: o se acredita completo, o no se acredita nada. No hay medias tintas.

---

## üîç Tipos de Storage en Soroban

En Soroban hay 3 tipos de storage. Usamos `instance()` pero es importante que conozcas los otros:

| Tipo | Duraci√≥n | Uso t√≠pico | Analog√≠a |
|------|----------|------------|----------|
| **Temporary** | Solo durante la transacci√≥n | C√°lculos intermedios | Post-it - se tira despu√©s |
| **Instance** | Duraci√≥n media, renovable | Datos del contrato | Disco duro - persiste pero pod√©s borrar |
| **Persistent** | Duraci√≥n larga | Datos cr√≠ticos | Blockchain - casi eterno |

**¬øPor qu√© usamos `instance()` en el contador?**
- Balance entre costo y duraci√≥n
- Para un contador simple, no necesitamos persistencia eterna
- M√°s barato que persistent, m√°s duradero que temporary

> üí° **Regla pr√°ctica:** Temporary = 1 transacci√≥n, Instance = semanas/meses, Persistent = a√±os. Eleg√≠ seg√∫n cu√°nto tiempo necesit√°s los datos.

---

## üí° Patrones que aprendiste

### Patr√≥n 1: Leer-Modificar-Guardar

```rust
let mut valor = storage.get(key).unwrap_or(default);  // Leer
valor += 1;                                            // Modificar
storage.set(key, &valor);                              // Guardar
```

**Usado en:** Contadores, balances, acumuladores

> üí° **Ejemplo real:** As√≠ funcionan los tokens. Leer balance, restar/sumar, guardar nuevo balance.

### Patr√≥n 2: Validar-Ejecutar-Emitir

```rust
if !es_valido { panic!("Error"); }  // Validar
ejecutar_logica();                   // Ejecutar
env.events().publish(...);           // Emitir
```

**Usado en:** Transferencias, validaciones de permisos

> üí° **Ejemplo real:** Transferir tokens. Validar que ten√©s suficiente balance, ejecutar transferencia, emitir evento "Transfer".

### Patr√≥n 3: Solo lectura sin mut

```rust
pub fn get_valor(env: Env) -> u32 {
    storage.get(key).unwrap_or(0)  // Solo lectura
}
```

**Usado en:** Queries, vistas, getters

> üí° **Ejemplo real:** Ver tu balance sin modificarlo. Gratis y r√°pido.

---

## üõ†Ô∏è Ejercicios guiados para practicar

### Ejercicio 1: increment_by (Nivel: F√°cil)

**Objetivo:** Agregar una funci√≥n que incremente por una cantidad espec√≠fica.

**Pasos sugeridos:**

```rust
pub fn increment_by(env: Env, amount: u32) -> u32 {
    // 1. Leer contador actual (igual que increment)
    // TU C√ìDIGO AC√Å
    
    // 2. VALIDACI√ìN: Verificar que amount + contador no cause overflow
    // Tip: us√° contador.checked_add(amount)
    // Si es None, hac√© panic! con mensaje apropiado
    // TU C√ìDIGO AC√Å
    
    // 3. Incrementar por amount
    // TU C√ìDIGO AC√Å
    
    // 4. Guardar en storage
    // TU C√ìDIGO AC√Å
    
    // 5. Emitir evento (usa topic "inc_by" y data: (amount, nuevo_valor))
    // TU C√ìDIGO AC√Å
    
    // 6. Retornar nuevo valor
    // TU C√ìDIGO AC√Å
}
```

**Test para tu funci√≥n:**

```rust
#[test]
fn test_increment_by() {
    let env = Env::default();
    let contract_id = env.register_contract(None, ContadorContract);
    let client = ContadorContractClient::new(&env, &contract_id);
    
    assert_eq!(client.increment_by(5), 5);
    assert_eq!(client.increment_by(3), 8);
    assert_eq!(client.get_count(), 8);
}

#[test]
#[should_panic(expected = "overflow")]
fn test_increment_by_overflow() {
    let env = Env::default();
    let contract_id = env.register_contract(None, ContadorContract);
    let client = ContadorContractClient::new(&env, &contract_id);
    
    // Intentar incrementar m√°s all√° del m√°ximo
    client.increment_by(u32::MAX);
    client.increment_by(1); // Esto debe causar panic
}
```

---

### Ejercicio 2: L√≠mite m√°ximo (Nivel: Medio)

**Objetivo:** Modificar el contador para que tenga un l√≠mite m√°ximo de 1000.

**Pasos sugeridos:**

1. Modific√° `increment()` para verificar si `contador < 1000` antes de incrementar
2. Si ya est√° en 1000, hac√© `panic!("contador alcanz√≥ el l√≠mite m√°ximo")`
3. Actualiz√° el test `test_increment` para verificar este l√≠mite
4. Agreg√° un nuevo test `test_increment_limit` que verifique el panic

**C√≥digo de ejemplo:**

```rust
pub fn increment(env: Env) -> u32 {
    let mut contador: u32 = env.storage()
        .instance()
        .get(&symbol_short!("COUNTER"))
        .unwrap_or(0);
    
    // VALIDACI√ìN NUEVA
    if contador >= 1000 {
        panic!("contador alcanz√≥ el l√≠mite m√°ximo de 1000");
    }
    
    contador += 1;
    
    // ... resto del c√≥digo igual
}
```

---

### Ejercicio 3: Experimentar con u8 (Nivel: Exploratorio)

**Objetivo:** Entender las limitaciones de tipos m√°s peque√±os.

**¬øQu√© pasa si cambias `u32` por `u8`?**

- `u8` va de 0 a 255
- Mucho m√°s limitado que `u32` (0 a 4,294,967,295)
- ¬øC√≥mo afecta esto a tu contador?

**Actividad:**

1. Cambi√° todos los `u32` por `u8` en el c√≥digo
2. Compil√° con `cargo build`
3. Ejecut√° los tests con `cargo test`
4. Observ√° qu√© pasa cuando el contador llega a 255
5. Reflexion√°: ¬øCu√°ndo usar√≠as u8? ¬øCu√°ndo u32? ¬øCu√°ndo u64?

> üí° **Reflexi√≥n:** Tipos m√°s peque√±os usan menos storage (m√°s barato), pero tienen menos rango. Es un trade-off. Para un contador simple, u32 es perfecto.

---

### Ejercicio 4: Decrement_by (Nivel: F√°cil-Medio)

**Objetivo:** Crear la contraparte de `increment_by`.

**Tu misi√≥n:**

```rust
pub fn decrement_by(env: Env, amount: u32) -> u32 {
    // 1. Leer contador actual
    // 2. Validar que contador >= amount (sino panic!)
    // 3. Restar amount
    // 4. Guardar en storage
    // 5. Emitir evento
    // 6. Retornar nuevo valor
}
```

**Pistas:**
- Similar a `decrement()` pero rest√°s `amount` en lugar de 1
- Validaci√≥n: `if contador < amount { panic!(...) }`
- Evento: usa topic "dec_by"

---

## üö® Errores comunes y c√≥mo solucionarlos

### Error 1: "cannot borrow as mutable"

```
error[E0596]: cannot borrow `contador` as mutable
```

**Causa:** Olvidaste poner `mut` en la declaraci√≥n de la variable.

**Soluci√≥n:**
```rust
// ‚ùå Mal
let contador: u32 = ...;
contador += 1;  // Error!

// ‚úÖ Bien
let mut contador: u32 = ...;
contador += 1;  // Funciona!
```

---

### Error 2: "no method named `unwrap_or`"

```
error[E0599]: no method named `unwrap_or` found for type `u32`
```

**Causa:** Est√°s tratando de usar `unwrap_or` en algo que no es un `Option`.

**Soluci√≥n:**
```rust
// ‚ùå Mal - storage.get() ya retorna Option
let contador = storage.get(key);
let valor = contador.unwrap_or(0).unwrap_or(0);  // Doble unwrap!

// ‚úÖ Bien
let contador = storage.get(key).unwrap_or(0);
```

---

### Error 3: "mismatched types" con Symbol

```
error[E0308]: mismatched types
expected `&Symbol`, found `Symbol`
```

**Causa:** Olvidaste el `&` antes de `symbol_short!`.

**Soluci√≥n:**
```rust
// ‚ùå Mal
storage.get(symbol_short!("COUNTER"))

// ‚úÖ Bien
storage.get(&symbol_short!("COUNTER"))
```

---

### Error 4: Tests fallan con "thread 'main' panicked"

**Causa:** El c√≥digo del contrato tiene un panic inesperado.

**C√≥mo debuggear:**
1. Ejecut√° `cargo test -- --nocapture` para ver todos los prints
2. Agreg√° `println!` en tu c√≥digo para ver valores intermedios
3. Verific√° que tus validaciones sean correctas

```rust
// Debugging temporal
let mut contador = storage.get(key).unwrap_or(0);
println!("Contador actual: {}", contador);  // Ver el valor
contador += 1;
println!("Contador nuevo: {}", contador);   // Ver despu√©s de incrementar
```

**Importante:** Record√° quitar los `println!` antes de deployar - en blockchain no funcionan igual que en tests.

---

### Error 5: "ContadorContractClient not found"

```
error[E0433]: failed to resolve: use of undeclared type `ContadorContractClient`
```

**Causa:** Los tests no pueden ver el Client generado autom√°ticamente.

**Soluci√≥n:**
```rust
// ‚úÖ Asegurate de tener estos imports en tu m√≥dulo de test
#[cfg(test)]
mod test {
    use super::*;  // ‚Üê Esto importa todo del m√≥dulo padre
    use soroban_sdk::Env;
    
    // ... tus tests
}
```

---

### Error 6: Overflow en producci√≥n

**S√≠ntoma:** El contador funciona en tests pero falla en testnet/mainnet.

**Causa:** En release mode, Rust no hace panic en overflow por defecto. El n√∫mero simplemente "da la vuelta".

**Soluci√≥n:** Us√° `checked_add` para operaciones cr√≠ticas:

```rust
// ‚ùå Riesgoso en producci√≥n
contador += 1;

// ‚úÖ Seguro - causa panic si hay overflow
contador = contador.checked_add(1)
    .expect("overflow al incrementar contador");
```

---

## üìö Recursos adicionales

### Para profundizar en Rust
- [Rust Book en Espa√±ol](https://book.rustlang-es.org/)
- [Rust by Example](https://doc.rust-lang.org/rust-by-example/)

### Para profundizar en Soroban
- [Documentaci√≥n oficial de Soroban](https://soroban.stellar.org/docs)
- [Ejemplos de contratos](https://github.com/stellar/soroban-examples)

### Comunidad
- [Stack Exchange - Stellar](https://stellar.stackexchange.com/)

---

## üéì Siguientes pasos

Ahora que entend√©s el c√≥digo:

### Nivel 1: Consolidar (Hoy)
1. ‚úÖ Ejecut√° todos los tests y verific√° que pasen
2. ‚úÖ Modific√° el mensaje de panic en `decrement`
3. ‚úÖ Agreg√° un `println!` en un test para ver c√≥mo debuggear

### Nivel 2: Practicar (Esta semana)
1. ‚úÖ Implement√° `increment_by` con tests completos
2. ‚úÖ Agreg√° l√≠mite m√°ximo al contador
3. ‚úÖ Experiment√° cambiando u32 por u8 y observ√° las diferencias

### Nivel 3: Crear (Pr√≥ximas semanas)
1. ‚úÖ Cre√° un contador con m√∫ltiples variables (por ejemplo, votos a favor y en contra)
2. ‚úÖ Agreg√° funcionalidad para que solo el "owner" pueda resetear
3. ‚úÖ Implement√° un contador con timestamp (registrar cu√°ndo se increment√≥)

**La mejor forma de aprender es rompiendo y arreglando.** ü¶à

---

## ü¶à ¬°Lo dominaste!

Tiburona, este contador es la base de TODO en Soroban:

| Aplicaci√≥n | C√≥mo usa el patr√≥n del contador |
|------------|----------------------------------|
| **Tokens** | Balances son contadores con validaciones |
| **NFTs** | IDs son contadores (tokenId auto-incrementa) |
| **Voting** | Votos son contadores por opci√≥n |
| **Staking** | Amounts y rewards son contadores |
| **Governance** | Proposal IDs son contadores |
| **Lottery** | Tickets vendidos = contador |

**El patr√≥n leer-validar-modificar-guardar-emitir es universal.**

No solo aprendiste a hacer un contador. Aprendiste:
- ‚úÖ C√≥mo manejar storage persistente
- ‚úÖ C√≥mo validar antes de modificar estado
- ‚úÖ C√≥mo usar eventos para transparencia
- ‚úÖ C√≥mo testear smart contracts
- ‚úÖ C√≥mo debuggear errores comunes
- ‚úÖ C√≥mo pensar en t√©rminos de blockchain

**Esto no es poca cosa, Tiburona.**

Ahora sos parte del 0.1% de personas que no solo entiende blockchain te√≥ricamente, sino que puede CONSTRUIR en blockchain.

---

## üéØ Checklist de dominio

Antes de pasar a la siguiente clase, verific√° que pod√©s:

- [ ] Explicar qu√© hace cada l√≠nea del contador
- [ ] Entender por qu√© usamos `&` (borrowing)
- [ ] Saber cu√°ndo usar `mut` y cu√°ndo no
- [ ] Comprender c√≥mo funciona `Option` con `unwrap_or`
- [ ] Explicar por qu√© validamos antes de modificar
- [ ] Entender la diferencia entre `increment` y `get_count`
- [ ] Ejecutar tests exitosamente
- [ ] Interpretar mensajes de error del compilador
- [ ] Modificar el c√≥digo sin romper la funcionalidad
- [ ] Crear nuevas funciones siguiendo los patrones aprendidos

Si marcaste 8+ items, **est√°s lista para la siguiente clase.** üéâ

Si marcaste menos, **no te preocupes.** Volv√© a leer las secciones que te confunden, experiment√° con el c√≥digo, y pregunt√° en clase o en Discord.

**Todas las Tiburonas empezamos en el mismo lugar. Lo importante es seguir nadando.** ü¶à

---

## üí≠ Reflexi√≥n final

> Este c√≥digo tiene ~100 l√≠neas pero usa todos los conceptos fundamentales de Rust para blockchain.
> 
> Dominalo y dominar√°s Rust para blockchain.
> 
> No te apures. No se trata de memorizar sintaxis.
> Se trata de entender patrones, validaciones, y c√≥mo proteger el estado en un ambiente sin confianza.
> 
> Cada vez que escribas c√≥digo de blockchain, vas a usar estos mismos patrones.
> Leer ‚Üí Validar ‚Üí Modificar ‚Üí Guardar ‚Üí Emitir.
> 
> Es simple. Es poderoso. Es universal.

---

## ü¶à‚ö° ¬°Vamos a construir, Tiburonas! ‚ö°ü¶à

Como las tiburonas reales:
- **Precisas:** Cada l√≠nea de c√≥digo tiene un prop√≥sito
- **Persistentes:** Seguimos construyendo aunque encontremos errores
- **Poderosas:** No solo hablamos de blockchain - la CONSTRUIMOS
- **Pioneras:** Pocas personas en el mundo pueden hacer lo que vos est√°s aprendiendo

Nos vemos en la Clase 4. Sigue construyendo, sigue nadando.

**Llev√° estos conceptos y practic√°. El pr√≥ximo nivel te espera.** üöÄ

---

> üí° **Record√°:** Ten√©s este documento cerca. Volv√© cuando necesites refrescar conceptos, cuando tengas dudas, o cuando quieras entender m√°s profundo. Es tu gu√≠a, no una tarea de una sola vez.